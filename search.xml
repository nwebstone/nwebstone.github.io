<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>TS_02</title>
      <link href="/posts/5.html"/>
      <url>/posts/5.html</url>
      
        <content type="html"><![CDATA[<h1 id="TS-02"><a href="#TS-02" class="headerlink" title="TS_02"></a>TS_02</h1><h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><p>JavaScript 语言中，生成实例对象的传统方法是通过构造函数</p><p>ES6之后开始使用class创建类</p><p><strong>类就是具有相同特征的一类事物,比如猫.狗..都是动物类,具有动物类的基本属性和行为</strong></p><p><strong>可以将具有共同特征的事物抽象为一个类,类中定义公共属性和公共方法</strong>,</p><pre class="line-numbers language-none"><code class="language-none">function Cat(name,color){   //构造函数     this.name = name;     this.color = color;     this.type='动物';     this.eat = function(){console.log("吃老鼠")};};原型中Cat.prototype.type='动物';Cat.prototype.eat = function () {     return console.log("吃老鼠");};var cat1 = new Cat("大明","黄色");var cat2 = new Cat("小明","白色");<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>使用class声明一个类</strong></p><p>在ts中声明一个类的时候,不要忘记指定类中属性类型,在定义函数的时候注意参数的类型</p><pre class="line-numbers language-none"><code class="language-none">class  Phone {  brand:string  price:number  color:string  constructor(brand:string,price:number,color:string){    this.brand = brand    this.price = price    this.color = color  }  static sendMessage(message:string,name:string){    console.log(`给${name}发送了一条消息,内容是${message}`);      }}Phone.sendMessage('你好!!','jack')<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h2><p>ts中引入的修饰符,可以对变量的访问权限进行限制</p><p>常用的修饰符有以下几个<strong>public,static,protected,private,abstract</strong></p><h3 id="public修饰符"><a href="#public修饰符" class="headerlink" title="public修饰符"></a>public修饰符</h3><p><strong>public修饰的属性在类的外部,子类,类的内部都可以访问到</strong></p><pre class="line-numbers language-none"><code class="language-none">class Person { //创建一个person类  public name:string  constructor(name:string){     this.name = name}  public run(){    console.log(`${this.name}在跑步`);      }}class youth extends Person{  constructor(name:string){    super(name)  }}let xiaohong = new youth('xiaohong')xiaohong.run()  //在父类外可以访问到父类属性与方法<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="protected"><a href="#protected" class="headerlink" title="protected"></a>protected</h3><p><strong>在类的外部访问不到属性,在类和子类的内部可以进行访问</strong></p><pre class="line-numbers language-none"><code class="language-none">export class Person {  protected name:string  constructor(name:string){     this.name = name}  public run(){    console.log(`${this.name}在跑步`);      }}class youth extends Person{  constructor(name:string){    super(name)  }  playGame(){    console.log(this.name,'玩游戏');      }}let xiaohong = new youth('xiaohong')xiaohong.run()  //在父类外可以访问到父类属性与方法// console.log(xiaohong.name); // 在类的外部是访问不到name属性的xiaohong.playGame() // 子类中可以访问方法和变量<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="private"><a href="#private" class="headerlink" title="private"></a>private</h3><p><strong>只能在当前的类中进行使用,不能再子类和父类中进行使用</strong></p><pre class="line-numbers language-none"><code class="language-none">export class Person {  private name:string  constructor(name:string){     this.name = name  }  private run(){    console.log(`${this.name}在跑步`);      }}class youth extends Person{  constructor(name:string){    super(name)  }  playGame(){    console.log(this.name,'玩游戏');      }}let xiaohong = new youth('xiaohong')// xiaohong.run()  //在父类外不可以访问到父类属性与方法// console.log(xiaohong.name); // 在类的外部是访问不到name属性的// xiaohong.playGame() // 子类中不可以访问方法和变量<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="抽象类与抽象方法"><a href="#抽象类与抽象方法" class="headerlink" title="抽象类与抽象方法"></a>抽象类与抽象方法</h3><p>抽象类: <strong>abstract 修饰</strong>， 里面可以定义<strong>普通方法和抽象方法</strong>,也<strong>可以不定义抽象方法</strong>。</p><p><strong>只要有抽象方法(abstract method)的类必须声明为抽象类(abstract class)</strong></p><p><strong>抽象方法的声明</strong></p><pre class="line-numbers language-none"><code class="language-none">abstract protected run(name:string):void<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>抽象方法不用在类中进行实现,继承抽象类的子类必须实现抽象类的方法</li><li>多态:<strong>父类定义一个方法不去实现，让继承它的子类去实现  每一个子类有不同的表现</strong></li><li>注意：<strong>使用多态基础是类的继承或者接口实现</strong></li></ul><pre class="line-numbers language-none"><code class="language-none">/** * Animal 是一个抽象类，里面含有一个eat()抽象方法 */abstract class Animal{    public name:string;    constructor(name:string){        this.name=name;    }     //抽象方法 ，不包含具体实现，要求子类中必须实现此方法    abstract eat():any;     //非抽象方法，无需要求子类实现、重写    run(){        console.log('非抽象方法，不要子类实现、重写');    }} class  Dog extends Animal{     //子类中必须实现父类抽象方法，否则ts编译报错    eat(){       return this.name+"吃肉";    }} class Cat extends Animal{     //子类中必须实现父类抽象方法，否则ts编译报错    eat(){        return this.name+"吃鱼";    }} var dog =new Dog("tom");var cat=new Cat("kitty");console.log(dog.eat());console.log(cat.eat()); //多态 ，一种事物的不同表现形态。如下面的代码中 先声明变量f是Animal类型，具体是Dog还是Cat，在new 对象时才知道//如果是Dog，则f.eat()调用的是Dog类中的eat方法；如果是Cat，则f.eat()调用的是Cat类中的eat方法，这就是多态！！！var f:Animal;//声明变量为Animal类型//f=new Dog("sunny");f=new Cat("sunny");console.log(f.eat());<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>这里的接口是一种变量,该变量中规定了一定的属性</p><h3 id="对象实现接口"><a href="#对象实现接口" class="headerlink" title="对象实现接口"></a>对象实现接口</h3><p>使用接口对对象中的变量进行规范约束</p><pre class="line-numbers language-none"><code class="language-none">interface obj {name:string,age:numberheight?:numberreadonly weight:number}//对象实现接口必须实现接口中的所有属性,不多不少let xiaoming:interface = {name:"xaioming",age:19,height:189,weight:180}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="类实现接口"><a href="#类实现接口" class="headerlink" title="类实现接口"></a>类实现接口</h3><p>类实现接口需要使用关键字<strong>implements</strong></p><p>类实现接口之后,必须实现接口中的所有属性和方法,但是类中还可以有其他的方法(只多不少)</p><pre class="line-numbers language-none"><code class="language-none">interface obj {name:stringage:number}class Person implements obj {name:string // 这是定义属性及类型age:number//height:numberconstructor(name:string){this.name=name}action(){console.log("正在跑步!")}}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="接口的功能-理解"><a href="#接口的功能-理解" class="headerlink" title="接口的功能(理解)"></a>接口的功能(理解)</h3><p>如果有一防盗门和一辆汽车都有报警和灯的功能</p><p>就可以将共同过的报警功能抽离出来,定义为一个接口,让防盗门和汽车都实现这个接口</p><p>接口中只是定义了相关属性和方法名及参数类型,不涉及实现功能,只提供一种规范</p><pre class="line-numbers language-none"><code class="language-none">interface Light{ //定义了一个灯的接口,其中有开关灯的方法  lightOff():void;  lightOn():void}interface Alarmer {//定义了一个报警的接口  alarm():void // 接口规定有一个alarm()方法}class Door{   //定义了一个通用的门类  constructor(){  }}class SecureDoor extends Door implements Alarmer,Light{   alarm(): void {//定义防盗门类,实现接口,实现接口中的方法      }  lightOff(): void {      }  lightOn(): void {      }}class Car implements Alarmer,Light {  alarm(): void {//实现接口方法      }  lightOff(): void {      }  lightOn(): void {      }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="接口与类的区别"><a href="#接口与类的区别" class="headerlink" title="接口与类的区别"></a>接口与类的区别</h3><p>​    <strong>类可以创建对象，接口不可以</strong></p><p>​    <strong>类只可以继承、接口是实现</strong></p><p>   <strong>一个类可以实现多个接口一个类只能继承一个类</strong></p><p>   <strong>一个接口既可以继承类又可以继承接口</strong></p><h3 id="接口继承接口"><a href="#接口继承接口" class="headerlink" title="接口继承接口"></a>接口继承接口</h3><p>​     <em>一个接口继承了另外一个接口，就继承了其中属性</em></p><p>  <strong>A</strong> extends  <strong>B</strong>   ==&gt;接口A继承了接口B,就继承了其中的属性与方法</p><p>  <strong>C</strong> implements  <strong>A</strong> ===》 C中要实现A和B两个接口中的属性</p><pre class="line-numbers language-none"><code class="language-none">//接口继承接口interface Animal{eat():void;}interface Person extends Animal{work():void;}class Web implements Person{name: stringconstructor(name:string){this.name = name}  [propName: string]: any;  age: number;  sex: string;eat () {console.log(`${this.name}喜欢吃馒头`)}work(){console.log(`${this.name}写代码`)}}var w = new Web('ruby')w.eat()w.work()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="接口继承类"><a href="#接口继承类" class="headerlink" title="接口继承类"></a>接口继承类</h3><p><strong>当接口继承了一个类类型时，它会继承类的成员但不包括其实现。</strong> 就好像接口声明了所有类中存在的成员，但并没有提供具体实现一样。</p><p><strong>接口同样会继承到类的private和protected成员。</strong> </p><p>这意味着当你创建了一个<strong>接口继承了一个拥有私有或受保护的成员的类时</strong>，这个<strong>接口类型只能被这个类或其子类</strong>所实现（implement）。</p><p>当你有一个庞大的继承结构时这很有用，但要指出的是你的代码<strong>只在子类拥有特定属性时起作用</strong>。 这个子类除了继承至基类外与基类没有任何关系。</p><pre class="line-numbers language-none"><code class="language-none">class Control { // 定义一个类    private state: any; // 定义一个私有属性}interface SelectableControl extends Control { // 接口继承了类    select(): void;}class Button extends Control implements SelectableControl { //  类继承了类由实现了接口    select() {}}class TextBox extends Control {  // 类继承了类}class Image implements SelectableControl {  //类实现接口    select() {}}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">出现以下的异常⨯ Unable to compile TypeScript:src/interface_8.ts(54,7): error TS2300: Duplicate identifier 'Image'.src/interface_8.ts(54,7): error TS2420: Class 'Image' incorrectly implements interface 'SelectableControl'.  Property 'state' is missing in type 'Image'.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>在上面的例子里，SelectableControl包含了Control的所有成员，包括私有成员state。</strong></p><h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><p>泛型就是使用一个泛型变量来表示任意的变量类型,在定义函数或者是指定数据类型的时候可以使用泛型.</p><h3 id="函数声明时使用泛型"><a href="#函数声明时使用泛型" class="headerlink" title="函数声明时使用泛型"></a>函数声明时使用泛型</h3><p>使用泛型定义函数,在函数调用的时候统一指定函数类型</p><p>泛型的使用有助于避免相同功能但是类型不同的函数</p><p>泛型函数,通常用来指定函数的参数类型\返回值类型</p><pre class="line-numbers language-none"><code class="language-none">function foo&lt;T&gt;(x:T,y:T):T[]{  return [x,y]}// 函数声明function f1&lt;T&gt;(x:T):T{  return x}f1&lt;number&gt;(1)// 函数表达式let f2 = function&lt;N&gt;(x:N):N{  return x}var funcTest = &lt;T&gt;(x:T):T=&gt; x<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="泛型约束"><a href="#泛型约束" class="headerlink" title="泛型约束"></a>泛型约束</h3><p>如何使用泛型指定几个类型的变量都有共同的属性</p><p>可以使用一个接口来约束变量类型具有什么样的属性,在使用泛型的时候让泛型变量受到接口的约束</p><pre class="line-numbers language-none"><code class="language-none">//错误示例//返回值是一个参数的长度,但是泛型函数的参数可以指定任意的类型,如果指定的类型是unmber,那么就是没有length属性的,如何指定泛型变量使用的是具有length属性的变量类型function func5&lt;T&gt; (arg: T): void {  console.log(arg.length);  // 错误: T不存在length属性  比如数值等}//解决方法//定义一个接口,接口中定义了length属性interface Length{length:number}//在使用泛型的时候让泛型变量受到接口的约束function func5&lt;T extends Length&gt; (arg: T): void {  console.log(arg.length);  }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="接口泛型"><a href="#接口泛型" class="headerlink" title="接口泛型"></a>接口泛型</h3><p>之前学过可以使用接口来规范函数的输入和输出</p><pre class="line-numbers language-none"><code class="language-none">interface SearchFun{ //定义一个接口,规范函数的输入和输出  (a:string,b:string):boolean}//函数实现接口let func6:SearchFun = function(str1:string,str:string):boolean{  let i = str1.search(str2)  return i === -1}func6('abc','a')<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>有些函数变量类型不同但是函数功能相同,可以使用泛型的形式进行书写</p><p>因为接口可以约束函数的类型,所以可以直接在接口中使用泛型</p><pre class="line-numbers language-none"><code class="language-none">function func&lt;T&gt;(a:T,b:T):T[]{return [a,b]}//方式2泛型接口,泛型类型写在接口名之后interface SearchFun&lt;T&gt;{(a:T,b:T):T[]}//实现接口的时候指定泛型变量let func:SearchFun&lt;string&gt; = function&lt;T&gt;(a:T,b:T):T[]{return[a,b]}func('abc','a')  //函数声明的时候不用加泛型//泛型接口,泛型变量写在函数之前interface SearchFun2{  &lt;T&gt;(a:T,b:T):boolean}let func7:SearchFun2 = function&lt;T&gt;(a:T,b:T):boolean{  return a === b}//使用函数的时候书写泛型func7&lt;string&gt;('abc','a')<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="数组泛型"><a href="#数组泛型" class="headerlink" title="数组泛型"></a>数组泛型</h3><pre class="line-numbers language-none"><code class="language-none">//定义一个普通函数,规定号函数的种类function createArray(num:number,str:string):string[]{  let a:string[] = []  for(let i = 0;i&lt;num;i++){    a[i] = str  }  return a}createArray(4,'abs')//使用泛型定义,可以在使用的时候指定数组变量的类型function createArray(num:number,str:string):string[]{  let a:string[] = []  for(let i = 0;i&lt;num;i++){    a[i] = str  }  return a}createArray(4,'abs')<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="枚举类型"><a href="#枚举类型" class="headerlink" title="枚举类型"></a>枚举类型</h2><p>enum类型是对JavaScript标准数据类型的一个补充<br>对于数组中获取数据，只能通过数组来获取，不能通过名称来获取</p><p>默认情况下，从0开始为元素编号。 你也可以手动的指定成员的数值。</p><p>如果第一变量指定为1,后面的依次增加1</p><pre class="line-numbers language-none"><code class="language-none">enum Color {  Red,  Green,  Blue}var co1:Color = Color.Redconsole.log(co1); // 0 可以通过值拿到索引,默认从零开始进行编号enum Color {  Red=1, // 可以手动指定成员的数值  Green,  Blue}var co1:Color = Color.Redconsole.log(co1); // 1 可以通过值拿到索引,默认从零开始进行编号var co2 = Color[2] //通过索引可以拿到对应的valuevar co3 = Color[1]var co4 = Color[0]var co5 = Color[3]console.log(co2); // Green,Red的起始值为1,后面依次增加console.log(co3)  console.log(co4);console.log(co5);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h2><p>数组合并了相同类型的对象，而元组（Tuple）合并了不同类型的对象。</p><p>我们知道数组中元素的数据类型都一般是相同的（any[] 类型的数组可以不同），如果存储的元素数据类<br>型不同，则需要使用元组</p><pre class="line-numbers language-none"><code class="language-none">let x: [number,string];x = [5,'abc']var ff =function(){     let x1: [string, number];     x1 = ['abc', 5];     x1[1] = 10;     console.log(x1); // ["abc", 10] }ff()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> -TypeScript </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>TS_01</title>
      <link href="/posts/4.html"/>
      <url>/posts/4.html</url>
      
        <content type="html"><![CDATA[<h1 id="TypeScript"><a href="#TypeScript" class="headerlink" title="TypeScript"></a>TypeScript</h1><h2 id="TS的数据类型"><a href="#TS的数据类型" class="headerlink" title="TS的数据类型"></a>TS的数据类型</h2><p>TS在定义变量的时候必须指定变量的数据类型</p><p>常用的数据类型</p><p>ES6:</p><pre class="line-numbers language-none"><code class="language-none">//基本数据类型StringNumberBooleannullSymbol//引用数据类型ArrayObjectFunction<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>TS:</p><pre><code>voidanynever元组枚举高级类型</code></pre><h3 id="基本使用形式"><a href="#基本使用形式" class="headerlink" title="基本使用形式"></a>基本使用形式</h3><p>使用<strong>变量:类型</strong>的形式声明一个变量</p><pre class="line-numbers language-none"><code class="language-none">//定义变量要指定参数的类型let num: number = 14;console.log(num);//函数在定义的时候,要指定参数的类型function  sum(num1:number,num2:number){  return num1+num2}// 基本数据类型的定义let flag:boolean = false;  //布尔类型let num:number = 15;  //数值类型let str:string = 'abc'; //字符串类型let str2:string=`hello,${str}`;let msg:string = `hello,${str},${num}`;let u: undefined = undefined;let n: null = null;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="联合类型"><a href="#联合类型" class="headerlink" title="联合类型"></a>联合类型</h3><p>联合类型,一个变量可以设置多个数据类型   <strong>变量:类型1 | 类型2  =值</strong></p><pre class="line-numbers language-none"><code class="language-none">let a:number|string<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="任意类型"><a href="#任意类型" class="headerlink" title="任意类型"></a>任意类型</h3><p>任意类型: 变量:any = 值</p><pre class="line-numbers language-none"><code class="language-none">let a : any<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="引用数据类型"><a href="#引用数据类型" class="headerlink" title="引用数据类型"></a>引用数据类型</h3><h4 id="数组的定义方式"><a href="#数组的定义方式" class="headerlink" title="数组的定义方式"></a>数组的定义方式</h4><h5 id="简单定义方式"><a href="#简单定义方式" class="headerlink" title="简单定义方式"></a>简单定义方式</h5><pre class="line-numbers language-none"><code class="language-none">// 数组,简单方式,  变量名:类型+[]let arr:number[]  = [1,2,3,4,6]let arr1:string[]  = ["a","b"]let arr2:any[] = []<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h5 id="数组泛型"><a href="#数组泛型" class="headerlink" title="数组泛型"></a>数组泛型</h5><p> <strong>数组泛型  <t> T为泛型变量   不指定变量的类型,而是在使用的时候进行定义类型</t></strong></p><p><strong>Array<t></t></strong></p><pre class="line-numbers language-none"><code class="language-none">let arr3:Array&lt;number&gt; = [2,3,4,5]let arr4:Array&lt;string|number&gt; = [2,3,4,5,"a"]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h5 id="使用接口定义数组"><a href="#使用接口定义数组" class="headerlink" title="使用接口定义数组"></a>使用接口定义数组</h5><pre class="line-numbers language-none"><code class="language-none">//定义接口,对对象属性约束interface&nbsp;Person{&nbsp;&nbsp;name:&nbsp;string;&nbsp;&nbsp;age:&nbsp;number;}//定义数组接口interface&nbsp;NumberArray&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[index:number]:&nbsp;Person;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}let&nbsp;arrType3:&nbsp;NumberArray&nbsp;=&nbsp;[{name:'张三'，age:&nbsp;20}]let&nbsp;arrType4：Array&lt;Person&gt;&nbsp;=&nbsp;[{name:'张三'，age:&nbsp;20}]let&nbsp;arrType5：Person[]&nbsp;=&nbsp;[{name:'张三'，age:&nbsp;20}]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>NumberArray 表示：只要 index 的类型是 number，那么值的结构类型必须是符合Person接口。</strong></p><h4 id="对象数据类型的定义"><a href="#对象数据类型的定义" class="headerlink" title="对象数据类型的定义"></a>对象数据类型的定义</h4><h5 id="对象及接口的定义"><a href="#对象及接口的定义" class="headerlink" title="对象及接口的定义"></a>对象及接口的定义</h5><p>接口:可以用于对对象的形状进行描述</p><p>接口:就是<strong>标准</strong>,比如不同的手机,要是有相同的接口就好了</p><p>​      对象<strong>实现接口</strong>,就要实现<strong>接口的标准</strong>,就相当于对对象进行了一个约束</p><p>​      *<em>定义方式,与类类似</em></p><pre class="line-numbers language-none"><code class="language-none">// 接口中规范了其中变量的类型interface Person{ //定义接口  readonly name:string;  // 只读属性  age?:number; // 可选属性  sex:string; // 必填属性  [propName:string]:any  //任意属性}/*对象实现了一个接口    对象:必须实现所有的接口属性,*/let obj:Person ={  name:'zs',  age:18,  sex:'male'}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​      <strong>接口就是用代码描述一个对象必须有什么属性（包括方法），但是有没有其他属性就不管了。</strong></p><p>​      <strong>1.声明变量使用接口的时候，变量参数必须和接口中的参数一致，不能多也不能少；</strong></p><p>​      <strong>2.readonly可以在接口中声明只读变量</strong></p><p>​      <strong>3.使用?可以声明一个变量在对象中是可选择的  比如name?: string</strong></p><p>​      <strong>4.[propName:类型]:any   任意属性  propName是一个变量</strong></p><p>​      <strong>一旦定义了任意属性,必填属性和可选属性必须是任意属性的自属性</strong> </p><p>​        <strong>只要propName的类型是string,他对应的值应该是any类型的</strong></p><h4 id="函数的定义"><a href="#函数的定义" class="headerlink" title="函数的定义"></a>函数的定义</h4><p>函数定义</p><p>函数声明,<strong>输入</strong>和<strong>输出</strong>的类型都要定义,有返回值必须规定类型,<strong>没有返回值使用void</strong></p><pre class="line-numbers language-none"><code class="language-none">//函数声明function(n1:number,n2:number) :number{  return  n1+n2}// 函数表达式let f3 = function(n1:number,n2:number):number{  return n1+n2}// 函数的默认值let f4 = function(n1:number=1,n2:number=2):number{  return n1+n2}// 可选参数,参数之后加?表示可选参数,可选参数必须在最后面let f5 = function(n1:number=1,n2?:number=2):number{  return n1+n2}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="接口在函数中的使用"><a href="#接口在函数中的使用" class="headerlink" title="接口在函数中的使用"></a>接口在函数中的使用</h5><p>参数是对象的时候,要对对象中的每个类型进行约束,写在形参的位置非常麻烦,使用接口简化</p><pre class="line-numbers language-none"><code class="language-none">function f6(obj:{id:number,name:string}):number{ //形参十分复杂,使用接口转化  return obj.id}let o = {id:2,name:"zs"}f6(o)//先定义接口,让参数对象实现接口即可interface objName{  id:number;  name:string}function f7(obj:objName):number{  return obj.id}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="接口声明函数"><a href="#接口声明函数" class="headerlink" title="接口声明函数"></a>接口声明函数</h5><pre class="line-numbers language-none"><code class="language-none">nterface&nbsp;SeachFunc{//函数接受两个参数&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;（source:string,subString:string）:boolean}&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;mySearch:SearchFunc;mySearch&nbsp;=&nbsp;function(source:&nbsp;string,subString:string){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;source.search(subString)&nbsp;!==&nbsp;-1&nbsp;&nbsp;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="联合属性在参数中使用"><a href="#联合属性在参数中使用" class="headerlink" title="联合属性在参数中使用"></a>联合属性在参数中使用</h5><p>联合属性在参数中使用,变量必须有两种类型共同的属性</p><pre class="line-numbers language-none"><code class="language-none">//这种定义方式是错误的,返回的是str的length属性,但是定义时有string和number两种属性//str是number时是没有length的,报错function f8(str:string|number):number{  return  str.length}//string和array都有长度function f8(str:string|Array&lt;string&gt;):number{  return  str.length}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="泛型在函数定义中的使用"><a href="#泛型在函数定义中的使用" class="headerlink" title="泛型在函数定义中的使用"></a>泛型在函数定义中的使用</h5><p>泛型,在定义函数或者是接口的时候不定义具体的变量类型,使用的时候在指定类型</p><pre class="line-numbers language-none"><code class="language-none">// 泛型,在定义函数或者是接口的时候不定义具体的变量类型,使用的时候在指定类型function f9(x:string,y:string):string[]{  return [x,y]}function f10(x:number,y:number):number[]{  return [x,y]}//前面两个函数只是变量类型不同,函数工能相同,使用泛型进行定义,简化代码function f11&lt;T&gt;(x:T,y:T):T[] {  return [x,y]}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="剩余参数在函数中的使用"><a href="#剩余参数在函数中的使用" class="headerlink" title="剩余参数在函数中的使用"></a>剩余参数在函数中的使用</h5><pre class="line-numbers language-none"><code class="language-none">//ES6...items在形参中使用,用在最后,拿到的是一个数组function&nbsp;push(array,...items){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;items.forEach(function(item){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;array.push(item)　　})&nbsp;&nbsp;}let&nbsp;a&nbsp;=&nbsp;[];push(a,1,2,3)// 传入第一个参数是一个数组,第二个参数也是一个数组,可以用数组类型function&nbsp;push(array:any[],...items:any[]){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;items.forEach(function(item){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;array.push(item);&nbsp;&nbsp;&nbsp;&nbsp;})&nbsp;&nbsp;}let&nbsp;a&nbsp;=&nbsp;[]push(a,1,2,3)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="undefined和null"><a href="#undefined和null" class="headerlink" title="undefined和null"></a>undefined和null</h3><pre class="line-numbers language-none"><code class="language-none">let&nbsp;udf:&nbsp;undefined&nbsp;=&nbsp;undefinedlet&nbsp;nu:&nbsp;null&nbsp;=&nbsp;null<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>在TS中,undefined和null是任何类型的子类型,所以可以被赋值给其他类型</p><pre class="line-numbers language-none"><code class="language-none">let&nbsp;num3:&nbsp;number&nbsp;|&nbsp;undefined&nbsp;|&nbsp;null&nbsp;=&nbsp;111<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="never"><a href="#never" class="headerlink" title="never"></a>never</h3><p>never:永远不会有返回值的类型</p><p><strong>1,函数抛出异常,永远不会有返回值,类型为never</strong></p><pre class="line-numbers language-none"><code class="language-none">//&nbsp;函数抛出异常,永远不会有返回值,类型为neverlet&nbsp;error&nbsp;=&nbsp;()&nbsp;=&gt;&nbsp;{throw&nbsp;new&nbsp;Error('error')}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>2,死循环函数永远没有返回值,类型为never</strong></p><pre class="line-numbers language-none"><code class="language-none">//&nbsp;死循环函数永远没有返回值,类型为neverlet&nbsp;endless&nbsp;=&nbsp;()&nbsp;=&gt;&nbsp;{while(true)&nbsp;{}}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="void"><a href="#void" class="headerlink" title="void"></a>void</h3><p>js中void操作符可以使任何一个表达式返回undefined</p><pre class="line-numbers language-none"><code class="language-none">void&nbsp;0&nbsp;//&nbsp;将返回undefined<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在TS中,void类型表示没有返回值,没有返回值的函数,他的类型就是void类型</p>]]></content>
      
      
      <categories>
          
          <category> -TypeScript </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>浏览器工作原理和V8引擎</title>
      <link href="/posts/3.html"/>
      <url>/posts/3.html</url>
      
        <content type="html"><![CDATA[<h1 id="浏览器工作原理和V8引擎"><a href="#浏览器工作原理和V8引擎" class="headerlink" title="浏览器工作原理和V8引擎"></a>浏览器工作原理和V8引擎</h1><p>前端开发最主要的就是<strong>html</strong> 、<strong>css</strong>、<strong>JavaScript</strong></p><p>Javascript是非常重要的</p><p>JavaScript是Vue、React、Angular、uniapp、taro、ReactNative的基础</p><h2 id="Javascript应用"><a href="#Javascript应用" class="headerlink" title="Javascript应用"></a>Javascript应用</h2><p>Web开发：React、Vue 、Angular</p><p>移动端开发:Reactive、Weex</p><p>小程序开发：微信小程序、支付宝小程序、uniapp、taro</p><p>桌面应用开发：Electron</p><p>后端开发：Node环境，比如express、koa、egg.js</p><h2 id="TypeScript会不会替代JavaScript"><a href="#TypeScript会不会替代JavaScript" class="headerlink" title="TypeScript会不会替代JavaScript??"></a>TypeScript会不会替代JavaScript??</h2><p>JavaScript是不会对变量进行检测，所以有很多方案，flow，TypeScript给js带来了类型检测的思想。</p><p>JavaScript是不会被替代的。</p><h2 id="语言分发展"><a href="#语言分发展" class="headerlink" title="语言分发展"></a>语言分发展</h2><p><strong>JS是一门高级的编程语言</strong></p><p>机器语言===》汇编语言===》高级语言（C 、C++、Java、JavaScript、Python</p><p>高级语言计算机是不认识的，需要将高级语言转变为机器指令</p><p><strong>计算机语言运行的过程</strong>:高级语言===》汇编语言===》机器语言</p><p>高级语言又可以分为解释型语言和编译型语言</p><p>C、C++是先将代码编译为可执行文件，是一种编译型语言</p><p>JS、Python是解释型语言</p><h2 id="JS是如何在浏览器中执行"><a href="#JS是如何在浏览器中执行" class="headerlink" title="JS是如何在浏览器中执行"></a>JS是如何在浏览器中执行</h2><p>node和浏览器中都已js的解析引擎</p><h3 id="浏览器下载资源的过程"><a href="#浏览器下载资源的过程" class="headerlink" title="浏览器下载资源的过程"></a><strong>浏览器下载资源的过程</strong></h3><p>在浏览器中输入 域名==》DNS解析为ip地址（服务器的地址）==》服务器会返回一个index.html网页</p><p>==》浏览器会对html页面进行解析==&gt;在解析html的过程中会遇到html、css、script，下载相应的资源</p><p>===》执行相应的资源的解析</p><h3 id="浏览器的内核"><a href="#浏览器的内核" class="headerlink" title="浏览器的内核"></a><strong>浏览器的内核</strong></h3><p>不同浏览器会又不同的内核</p><p>GecKo:早期被NetScope和Mozilla、Firefox使用</p><p>Trident:微软开发，被IE4-IE11浏览器使用，但是Edge浏览器已经转向Blink</p><p>Webkit:苹果基于KHTML开发、开源，用与Safari，Chrome之前也进行使用</p><p>Blink:是WebKit的一个分支，Google开发，目前应用于Google Chrome、Edge、Opera浏览器</p><p><strong>常说的浏览器内核指的是浏览器的排版引擎</strong></p><p>排版引擎（layout engine)，也称为浏览器引擎（browser engine)、页面渲染引擎（rendering engine)</p><h3 id="浏览器的渲染过程"><a href="#浏览器的渲染过程" class="headerlink" title="浏览器的渲染过程"></a>浏览器的渲染过程</h3><h4 id="loader"><a href="#loader" class="headerlink" title="loader"></a>loader</h4><p>　Loader模块负责处理所有的HTTP请求以及网络资源的缓存，相当于是从URL输入到Page Resource输出的变换过程。HTML页面中通常有外链的JS/CSS/Image资源，为了不阻塞后续解析过程，一般会有两个IO管道同时存在，一个负责主页面下载，一个负责各种外链资源的下载。</p><p><img src="C:\Users\admin\AppData\Roaming\Typora\typora-user-images\1650181674551.png" alt="1650181674551"></p><p>　注意：虽然大部分情况下不同资源可以并发下载异步解析（如图片资源可以在主页面解析显示完成后再被显示），但JS脚本可能会要求改变页面，因此有时保持执行顺序和下载管道后续处理的阻塞是不可避免的</p><h4 id="渲染过程"><a href="#渲染过程" class="headerlink" title="渲染过程"></a>渲染过程</h4><p>1、浏览器首先下载下来的是html,浏览器内核中的html parser将html转变为DOM树。</p><p>​    <strong>注意：</strong>DOM形成之后，JavaScript可以对DOM进行操作 </p><p>​    同时css样式也会被css parser进行解析成为css rules</p><p>​    DOM tree + css rules  形成render tree</p><p><img src="https://s3.bmp.ovh/imgs/2022/04/18/d5273e4b5e1fe25f.jpg"></p><p>2、layout计算（根据浏览器的大小和状态），计算出最终的render tree</p><p>3、painting</p><p>4、display    </p><p><img src="C:\Users\admin\AppData\Roaming\Typora\typora-user-images\1650181343218.png" alt="1650181343218"></p><p><img src="C:\Users\admin\AppData\Roaming\Typora\typora-user-images\1650181359587.png" alt="1650181359587"></p><p><strong>jS代码可能对dom进行操作，可能发起请求，所以在生成dom之后会执行js</strong></p><h3 id="JS引擎"><a href="#JS引擎" class="headerlink" title="JS引擎"></a>JS引擎</h3><p>高级语言==》浏览器和node==》最终仍然是被计算机所执行</p><p>但是CPU只认识自己的指令集，实际上是机器语言，才能被CPU执行</p><p>JS引擎：将JS转换为机器语言</p><h4 id="常见的JS引擎："><a href="#常见的JS引擎：" class="headerlink" title="常见的JS引擎："></a>常见的JS引擎：</h4><p>SpiderMonkey:收款JS引擎</p><p>Chakra:微软开发，用于IT浏览器</p><p>JSCore：WebKit中的JS浏览器</p><p>V8引擎：Google开发的</p><h4 id="JS引擎与浏览器内核的关系"><a href="#JS引擎与浏览器内核的关系" class="headerlink" title="JS引擎与浏览器内核的关系"></a>JS引擎与浏览器内核的关系</h4><p>V8引擎是使用C++编写的，开源的高性能的JS和WebAssembly引擎，用于Chrome和Node.js等</p><p>实现ECMAScript和WebAssembly，并在Windows7或者更高版本使用，mac OS10.12+</p><h4 id="JS引擎解析过程描述"><a href="#JS引擎解析过程描述" class="headerlink" title="JS引擎解析过程描述"></a><strong>JS引擎解析过程描述</strong></h4><p>JS===&gt;V8引擎Parser解析(词法分析和语法分析===》解析成ast树（抽象语法树）</p><p>​                                                                                ===》ignition<strong>转变为字节码</strong>==》执行</p><p>词法分析：将关键字，标识符，变量进行解析称号对象形式</p><pre class="line-numbers language-none"><code class="language-none">const name = 'zs'将词解析为tokens:[{type:"keyword",value:"const"},{type:"identifier",value:"name"}.....]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>ast树可以被<strong>ignition</strong>被转换为<strong>字节码</strong></p><h4 id="JS代码为什么不能直接转变为机器指令而是转变为字节码？？"><a href="#JS代码为什么不能直接转变为机器指令而是转变为字节码？？" class="headerlink" title="JS代码为什么不能直接转变为机器指令而是转变为字节码？？"></a><strong>JS代码为什么不能直接转变为机器指令而是转变为字节码？？</strong></h4><p>字节码是<strong>跨平台的</strong>，在任何一个平台再将字节码转变为汇编指令，再转变为机器指令，运行</p><p><strong>一个函数，如果多次执行，每次指向都要进行由字节码到汇编指令，再转变为机器指令的过程，很浪费性能，如何进行解决？？</strong></p><p>V8引擎中<strong>TurboFan</strong>会收集信息，将多次执行的代码标记为<strong>hot</strong>，将这些代码转变的机器指令存储起来，下次执行时可以方便调用。</p><p>如果一个函数或者时方法前后两次传递的参数类型不一致，V8引擎中有<strong>Deoptimization</strong>，将之前保存的<strong>函数机器指令再次转变为字节码，重新转换机器指令，进行执行</strong>，相当V8引擎进行代码优化。</p><p><strong>如果编写的时TypeScript代码，指向效率会比原生的JS语法高，因为规定了相应的数据类型</strong></p><p><img src="https://s3.bmp.ovh/imgs/2022/04/18/d7ccb2681adfb83a.jpg"></p><h4 id="抽象语法树的应用"><a href="#抽象语法树的应用" class="headerlink" title="抽象语法树的应用"></a><strong>抽象语法树的应用</strong></h4><p>babel：ts==》ast树==》generate code ==&gt;js代码</p><p>vue中的中渲染结构==》最终都是执行的render函数==》template==&gt;要将html字符串转变为结构，</p><p>​            字符串==》ast树==》VS Node==》html结构</p><h4 id="JS的预解析过程"><a href="#JS的预解析过程" class="headerlink" title="JS的预解析过程"></a>JS的预解析过程</h4><p>Bink将源码交给V8引擎，Stream获取到源码并且进行编码转换</p><p>Scanner会对源码进行词法解析，词法分析会将代码解析成为tokens</p><p>接下来tokens会被转化称为sat树,经过PreParser和Parser:</p><p>​        1.Parser就是直接将tokens转变为ast树</p><p>​        2.PreParser称之为预解析,为什么需要进行预解析</p><p>​         这是因为并不是所有的JS代码，在一开始的时候就会被执行，如果对所有的js代码都解析会影响网页的运行效率。</p><p>​         V8引擎实现类Lazy Parsing(延迟解析)，作用是将暂时不必要的函数进行预解析，也就是说只解析暂时需要的内容，而对函数的全量解析在函数被调用的时候才会进行。</p><pre class="line-numbers language-none"><code class="language-none">function outer(){function inner(){console.log('inner')}}outer()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>outer内部定义了inner函数，但是inner函数没有被调用，所以只会对其进行预解析</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>JS的重要性</p><p>浏览器的工作原理</p><p>使用到V8引擎中的loader,parser,Ignition，turboFan等模块</p><p><img src="https://s3.bmp.ovh/imgs/2022/04/18/816e9335a20c89ff.jpg" alt="1650182113891"></p><h1 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h1><h3 id="全局变量的解析过程"><a href="#全局变量的解析过程" class="headerlink" title="全局变量的解析过程"></a>全局变量的解析过程</h3><pre class="line-numbers language-none"><code class="language-none">var name = 'zs'var num1 = 20var num2 = 30var result = num1+num2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>解析过程</strong></p><p>  1、代码解析</p><p>​     a.在进行解析之前V8引擎在堆内存中会创建一个**globalObject对象（全局对象Go)**，会有String,Date,Number…全局内容）</p><p>​    b.在这个对象中有一个<strong>window属性</strong>，这个属性<strong>指向globalObject(自己的属性指向自己)</strong></p><p>​    c.解析代码时候，会将全局的<strong>属性挂载到全局对象当中，但是这个属性是没有值的,全部都是undefined</strong></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">//以一段伪代码表示</span><span class="token comment">// 伪代码,此时函数还没有执行</span><span class="token keyword">var</span> globalObject<span class="token operator">=</span> <span class="token punctuation">{</span>  String<span class="token operator">:</span><span class="token string">"类"</span><span class="token punctuation">,</span>  Date<span class="token operator">:</span><span class="token string">"类"</span><span class="token punctuation">,</span>  setTimeout<span class="token operator">:</span><span class="token string">"函数"</span><span class="token punctuation">,</span>  name<span class="token operator">:</span><span class="token keyword">undefined</span><span class="token punctuation">,</span>  num1<span class="token operator">:</span><span class="token keyword">undefined</span><span class="token punctuation">,</span>  result<span class="token operator">:</span><span class="token keyword">undefined</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>  <strong>此时,在函数定义之打印变量的值,会得到undefined,但不会报错</strong></p><p>2、运行代码</p><p>​    a.为了执行代码，V8引擎会创建<strong>执行上下文栈（函数调用栈）</strong>（Executions Context Stack  ECSSstack）</p><p>​      代码运行会先从磁盘加载到内存中，会对内存进行划分，一个是栈结构，一个是堆结构。</p><p>​      代码想要执行的时候需要放到执行上下文栈中进行执行，执行完之后弹出栈。</p><p>​    b.一般执行上下文栈式放的是函数的，为了全局代码能够执行，会创建<strong>全局执行上下文</strong>（Global Execution Context Stack  <strong>GEC</strong>)</p><p>​      这里的代码不是函数,为了执行这些代码,会创建全局执行上下文</p><p>​       全局执行上下文就可以放入到执行上下文栈中进行执行</p><p>​       <strong>全局执行上下文中维护的是VO(variable Object 变量对象),VO指向的是GO</strong></p><p>​    *<em>依次执行代码**</em></p><p><img src="https://s3.bmp.ovh/imgs/2022/04/18/7801d855b9a7b796.jpg"></p><h3 id="函数的解析"><a href="#函数的解析" class="headerlink" title="函数的解析"></a>函数的解析</h3><p> 1.解析过程</p><p>​    a.V8创建全局对象,将name添加到GO中</p><p>​    b.编译解析过程是不会执行函数的,所以就跳过foo(),继续向后编译</p><p>​    c.遇到函数定义之后,将foo属性中添加到GO中,<strong>V8此时会开辟一块内存空间(有一个内存地址,比如0xa00),存储函数</strong></p><p>​    这个空间主要包括两部分,一个是<strong>父级作用域</strong>,就是函数的上一层作用域,另一部分保存<strong>函数的函数体</strong></p><p>​    <strong>GO中foo属性对应的是函数的地址</strong></p><p>  2.执行过程</p><p>​    a.var name= ‘zs’,通过VO找到GO,更改值</p><p>​    b.指向到foo(),<strong>通过VO找到GO中的foo==&gt;对应的函数地址====&gt;此时创建函数执行上下文(Functiona Execution Context  FEC)</strong></p><p>​      函数执行上下文中也有一个VO,这个VO指向的是<strong>AO(Activation Object)</strong></p><p>​      在函数执行之前会创建AO,<strong>AO存放的是函数内部定义的变量,作用类似于GO,AO中的变量开始也是undefined,函数执行完毕后,函数的</strong></p><p>​      执行上下文弹出,会被销毁掉,如果再次执行上下文会再次创建函数执行上下文</p><pre class="line-numbers language-none"><code class="language-none">//函数解析示例var name="zs"foo()function foo() {  console.log("foo");}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://s3.bmp.ovh/imgs/2022/04/18/310748db1bf46f73.jpg" alt="函数解析过程"></p>]]></content>
      
      
      <categories>
          
          <category> -JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -JS进阶 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTML_01</title>
      <link href="/posts/2.html"/>
      <url>/posts/2.html</url>
      
        <content type="html"><![CDATA[<h1 id="HTML-01"><a href="#HTML-01" class="headerlink" title="HTML_01"></a>HTML_01</h1><h2 id="网页"><a href="#网页" class="headerlink" title="网页"></a>网页</h2><h3 id="什么是网页？"><a href="#什么是网页？" class="headerlink" title="什么是网页？"></a>什么是网页？</h3><p>网站是指在因特网上根据一定的规则，使用 HTML 等制作的用于展示特定内容相关的网页集合。</p><p>网页是网站中的一“页”，通常是 HTML 格式的文件，它要通过浏览器来阅读。</p><p><strong>网页是构成网站的基本元素</strong>，它通常由图片、链接、文字、声音、视频等元素组成。通常我们看到的网页，<br>常见以 .<strong>htm</strong> 或 <strong>.html</strong> 后缀结尾的文件，因此将其俗称为 HTML 文件。</p><h2 id="常用浏览器"><a href="#常用浏览器" class="headerlink" title="常用浏览器"></a>常用浏览器</h2><p>浏览器最主要的部分是浏览器内核，负责读取网页内容，整理讯息，计算网页的显示方式并显示页面。</p><table><thead><tr><th>浏览器</th><th>内核</th><th>备注</th></tr></thead><tbody><tr><td>IE</td><td>Trident</td><td>IE、360极速浏览器、百度浏览器</td></tr><tr><td>Firefox</td><td>Gecko</td><td>火狐浏览器内核</td></tr><tr><td>Safari</td><td>Webkit</td><td>苹果浏览器内核</td></tr><tr><td>Chrome/Opera</td><td>Bink</td><td>Chrome/Opera浏览器内核，Bink其实是WebKit的分支</td></tr></tbody></table><h1 id="Web标准"><a href="#Web标准" class="headerlink" title="Web标准"></a>Web标准</h1><p>Web 标准是由 <strong>W3C 组织</strong>和其他标准化组织制定的一系列标准的集合。<strong>W3C（万维网联盟）</strong>是国际最著名的标准化组织。</p><h2 id="为什么指定Web标准？"><a href="#为什么指定Web标准？" class="headerlink" title="为什么指定Web标准？"></a>为什么指定Web标准？</h2><p>不同的浏览器解析相同的html文件会有差异。</p><p><strong>制定web标准的优点</strong>：使网站便于维护，网页内容能够被更加广泛的设备访问。</p><h2 id="Web标准的构成"><a href="#Web标准的构成" class="headerlink" title="Web标准的构成"></a>Web标准的构成</h2><p>一个页面主要有三部分组成：结构、样式和行为，分别对应前端必备技术，html，css，javascipt</p><table><thead><tr><th>标准</th><th>说明</th></tr></thead><tbody><tr><td>结构（html）</td><td>搭建网页的基本结构，实现网页的布局</td></tr><tr><td>样式（css)</td><td>用于美化页面，网页元素的大小，颜色，样式</td></tr><tr><td>行为（javascript)</td><td>实现网页的动态效果和页面与用户的交互行为</td></tr></tbody></table><h2 id="HTML基本标签"><a href="#HTML基本标签" class="headerlink" title="HTML基本标签"></a>HTML基本标签</h2><p>html页面中的基本标签结构</p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span><span class="token punctuation">&gt;</span></span>   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">&gt;</span></span>标题<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">&gt;</span></span>    主要内容  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在使用vscode时，使用<strong>！+tab</strong>可以自动给创建html文件的表头</p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token comment">&lt;!-- 文档类型的声名，告诉浏览器使用哪种HTML版本来显示网页，文档类型声名在最前面 --&gt;</span><span class="token doctype"><span class="token punctuation">&lt;!</span><span class="token doctype-tag">DOCTYPE</span> <span class="token name">html</span><span class="token punctuation">&gt;</span></span><span class="token comment">&lt;!-- 定义当前文档显示的语言 en是英语 zh-CN是中文网页 --&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span> <span class="token attr-name">lang</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>en<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">&gt;</span></span>  <span class="token comment">&lt;!-- 定义使用哪种字符编码 --&gt;</span>  <span class="token comment">&lt;!-- 常用的字符编码格式：GB2312，BIG5,GBK，UTF-8(万国码)最常用 --&gt;</span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>UTF-8<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>  <span class="token comment">&lt;!-- 兼容性 --&gt;</span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">http-equiv</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>X-UA-Compatible<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>IE=edge<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>  <span class="token comment">&lt;!-- 视口 --&gt;</span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>viewport<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>width=device-width, initial-scale=1.0<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">&gt;</span></span>标题<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">&gt;</span></span>     主要内容<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="HTML常用标签"><a href="#HTML常用标签" class="headerlink" title="HTML常用标签"></a>HTML常用标签</h2><p>标签具有语义化可以是页面的结构更加的清晰</p><h3 id="h标签"><a href="#h标签" class="headerlink" title="h标签"></a>h标签</h3><p>h是head的缩写，标题标签，共有六个等级，从<strong>h1</strong>到<strong>h6</strong>依次减小</p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h1</span><span class="token punctuation">&gt;</span></span>标题内容<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h1</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>主要</strong>：在h标签中文字会加粗变大，<strong>一个标签独占一行</strong></p><h3 id="p标签"><a href="#p标签" class="headerlink" title="p标签"></a>p标签</h3><p>p是paragraph的缩写，段落标签，在标签内的为你单独为一个段落。</p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">&gt;</span></span>这是一个段落标签<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>注意：</strong>段落中的文字会根究浏览器窗口的大小自动换行，段落与段落之间会有空隙。</p><h3 id="br标签"><a href="#br标签" class="headerlink" title="br标签"></a>br标签</h3><p>网页中的文本只有在到达浏览器右端的时候才能进行自动换行，如果希望某段文本进行强制换行可以使用br标签</p><pre class="line-numbers language-none"><code class="language-none">&lt;br /&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>注意</strong>：br标签是一个单标签，br标签换行之后的文本上下是没有空袭的，段落标签换行后会形成两个段落，上下两个段落之间会有一定的空隙。</p><h3 id="文本格式化标签"><a href="#文本格式化标签" class="headerlink" title="文本格式化标签"></a>文本格式化标签</h3><p>文本格式化标签就是给文本添加一定样式的标签。</p><table><thead><tr><th>语义</th><th>标签</th><th>说明</th></tr></thead><tbody><tr><td>加粗</td><td><strong></strong>或者是<b></b></td><td>strong标签语义更加强烈</td></tr><tr><td>倾斜</td><td><em></em>或者<i><i></i></i></td><td><strong>经常全局曲消倾斜，用i标签放置小图标</strong></td></tr><tr><td>删除线</td><td><del></del>或者<s><s></s></s></td><td>del标签语义更加强烈</td></tr><tr><td>下划线</td><td><ins></ins>或者<u></u></td><td>ins标签语义更加强烈</td></tr></tbody></table><h3 id="div与span标签"><a href="#div与span标签" class="headerlink" title="div与span标签"></a>div与span标签</h3><p><strong>div：是用来进行布局的，但是一行只能放一个</strong></p><p><strong>span：用于布局，一行可以有多个span标签</strong></p><p>这里只简单了解一些两个标签不同，后面会详细说明。</p><h3 id="图像标签"><a href="#图像标签" class="headerlink" title="图像标签"></a>图像标签</h3><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token comment">&lt;!--img标签用于定义页面中的图像--&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>img</span>      <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>图片存放的路径<span class="token punctuation">"</span></span>      <span class="token attr-name">alt</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>加载不出来时显示文本<span class="token punctuation">"</span></span>      <span class="token attr-name">title</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span>“鼠标经过之后会显示图片的标题”</span>     <span class="token attr-name">width</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span>“100px”</span> <span class="token attr-name">设置宽度</span>     <span class="token attr-name">height</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>100px<span class="token punctuation">"</span></span> <span class="token attr-name">设置高度</span>     <span class="token attr-name">border</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span>“1px”</span> <span class="token attr-name">设置边框</span><span class="token punctuation">/&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="相对路径与绝对路径"><a href="#相对路径与绝对路径" class="headerlink" title="相对路径与绝对路径"></a>相对路径与绝对路径</h3><p>相对路径：相对于当前文件的路径来说的，写路径的时候从当前路径开始写</p><p><strong>./表示当前路径</strong></p><p><strong>../表示上一级路径</strong></p><p>绝对路径：从磁盘的根路径开始找 比如c:/……</p><p><strong>绝对路径的缺点:如果将文件发给别人使用,会找不到资源</strong></p><h1 id="a标签"><a href="#a标签" class="headerlink" title="a标签"></a>a标签</h1><p>超链接标签</p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token comment">&lt;!--_blnk在新的页面打开链接_self在当前页面打开链接herf链接可以是外部链接如www.baidu.com可以是空链接 herf="#"可以是内部的链接 herf="index.html"--&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">herf</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>点击之后要跳转的链接<span class="token punctuation">"</span></span> <span class="token attr-name">target</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>_blank/_self<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>文本\图像\表格<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="标签中的特殊字符"><a href="#标签中的特殊字符" class="headerlink" title="标签中的特殊字符"></a>标签中的特殊字符</h3><p><img src="C:\Users\admin\AppData\Roaming\Typora\typora-user-images\1650164110538.png" alt="1650164110538"></p>]]></content>
      
      
      <categories>
          
          <category> -HTML </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>02-博客诞生</title>
      <link href="/posts/1.html"/>
      <url>/posts/1.html</url>
      
        <content type="html"><![CDATA[<h1 id="博客诞生"><a href="#博客诞生" class="headerlink" title="博客诞生"></a>博客诞生</h1>]]></content>
      
      
      <categories>
          
          <category> -生活 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>博客与博主</title>
      <link href="/posts/1.html"/>
      <url>/posts/1.html</url>
      
        <content type="html"><![CDATA[<p>相遇皆是缘分</p><h3 id="为什么建博客？"><a href="#为什么建博客？" class="headerlink" title="为什么建博客？"></a>为什么建博客？</h3><p>肿么说了! 纯属个人兴趣，好玩，唉，就是玩!嘻嘻! 会有些成就感吧,拥有一个自己的博客写一些自己感兴趣的事或物,不是一件很酷的事嘛!</p><h3 id="展望博客"><a href="#展望博客" class="headerlink" title="展望博客"></a>展望博客</h3><p>我会整理一些个人所学的知识（学前端的，也会捣鼓捣鼓一些其它的专业的知识）或生活方面有兴趣的事发到博客上供大家观摩</p><h3 id="关于博主"><a href="#关于博主" class="headerlink" title="关于博主"></a>关于博主</h3><p>有位可爱的（小）朋友，给我取名叫 “仙气”，这是也是我博客上自居 “仙气” 的由来。喜欢自己所喜欢的，做自己想做的，追求自由与潇洒，多酷啊！ 想法是美好的，可现实… …   给大家推荐一首诗吧</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"> 《自由与爱情》---作者:裴多菲​ 生命诚可贵​ 爱情价更高​ 若为自由故​ 二者皆可抛<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>溜溜球啦！</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
