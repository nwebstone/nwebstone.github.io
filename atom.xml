<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ZY_LHC的博客</title>
  
  <subtitle>ZYLHCの博客</subtitle>
  <link href="https://nwebstone.github.io/atom.xml" rel="self"/>
  
  <link href="https://nwebstone.github.io/"/>
  <updated>2022-04-17T16:39:47.058Z</updated>
  <id>https://nwebstone.github.io/</id>
  
  <author>
    <name>ZYLHC</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>TS_01</title>
    <link href="https://nwebstone.github.io/posts/4.html"/>
    <id>https://nwebstone.github.io/posts/4.html</id>
    <published>2022-04-17T15:45:19.000Z</published>
    <updated>2022-04-17T16:39:47.058Z</updated>
    
    <content type="html"><![CDATA[<h1 id="TypeScript"><a href="#TypeScript" class="headerlink" title="TypeScript"></a>TypeScript</h1><h2 id="TS的数据类型"><a href="#TS的数据类型" class="headerlink" title="TS的数据类型"></a>TS的数据类型</h2><p>TS在定义变量的时候必须指定变量的数据类型</p><p>常用的数据类型</p><p>ES6:</p><pre class="line-numbers language-none"><code class="language-none">//基本数据类型StringNumberBooleannullSymbol//引用数据类型ArrayObjectFunction<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>TS:</p><pre><code>voidanynever元组枚举高级类型</code></pre><h3 id="基本使用形式"><a href="#基本使用形式" class="headerlink" title="基本使用形式"></a>基本使用形式</h3><p>使用<strong>变量:类型</strong>的形式声明一个变量</p><pre class="line-numbers language-none"><code class="language-none">//定义变量要指定参数的类型let num: number = 14;console.log(num);//函数在定义的时候,要指定参数的类型function  sum(num1:number,num2:number){  return num1+num2}// 基本数据类型的定义let flag:boolean = false;  //布尔类型let num:number = 15;  //数值类型let str:string = 'abc'; //字符串类型let str2:string=`hello,${str}`;let msg:string = `hello,${str},${num}`;let u: undefined = undefined;let n: null = null;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="联合类型"><a href="#联合类型" class="headerlink" title="联合类型"></a>联合类型</h3><p>联合类型,一个变量可以设置多个数据类型   <strong>变量:类型1 | 类型2  =值</strong></p><pre class="line-numbers language-none"><code class="language-none">let a:number|string<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="任意类型"><a href="#任意类型" class="headerlink" title="任意类型"></a>任意类型</h3><p>任意类型: 变量:any = 值</p><pre class="line-numbers language-none"><code class="language-none">let a : any<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="引用数据类型"><a href="#引用数据类型" class="headerlink" title="引用数据类型"></a>引用数据类型</h3><h4 id="数组的定义方式"><a href="#数组的定义方式" class="headerlink" title="数组的定义方式"></a>数组的定义方式</h4><h5 id="简单定义方式"><a href="#简单定义方式" class="headerlink" title="简单定义方式"></a>简单定义方式</h5><pre class="line-numbers language-none"><code class="language-none">// 数组,简单方式,  变量名:类型+[]let arr:number[]  = [1,2,3,4,6]let arr1:string[]  = ["a","b"]let arr2:any[] = []<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h5 id="数组泛型"><a href="#数组泛型" class="headerlink" title="数组泛型"></a>数组泛型</h5><p> <strong>数组泛型  <t> T为泛型变量   不指定变量的类型,而是在使用的时候进行定义类型</t></strong></p><p><strong>Array<t></t></strong></p><pre class="line-numbers language-none"><code class="language-none">let arr3:Array&lt;number&gt; = [2,3,4,5]let arr4:Array&lt;string|number&gt; = [2,3,4,5,"a"]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h5 id="使用接口定义数组"><a href="#使用接口定义数组" class="headerlink" title="使用接口定义数组"></a>使用接口定义数组</h5><pre class="line-numbers language-none"><code class="language-none">//定义接口,对对象属性约束interface&nbsp;Person{&nbsp;&nbsp;name:&nbsp;string;&nbsp;&nbsp;age:&nbsp;number;}//定义数组接口interface&nbsp;NumberArray&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[index:number]:&nbsp;Person;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}let&nbsp;arrType3:&nbsp;NumberArray&nbsp;=&nbsp;[{name:'张三'，age:&nbsp;20}]let&nbsp;arrType4：Array&lt;Person&gt;&nbsp;=&nbsp;[{name:'张三'，age:&nbsp;20}]let&nbsp;arrType5：Person[]&nbsp;=&nbsp;[{name:'张三'，age:&nbsp;20}]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>NumberArray 表示：只要 index 的类型是 number，那么值的结构类型必须是符合Person接口。</strong></p><h4 id="对象数据类型的定义"><a href="#对象数据类型的定义" class="headerlink" title="对象数据类型的定义"></a>对象数据类型的定义</h4><h5 id="对象及接口的定义"><a href="#对象及接口的定义" class="headerlink" title="对象及接口的定义"></a>对象及接口的定义</h5><p>接口:可以用于对对象的形状进行描述</p><p>接口:就是<strong>标准</strong>,比如不同的手机,要是有相同的接口就好了</p><p>​      对象<strong>实现接口</strong>,就要实现<strong>接口的标准</strong>,就相当于对对象进行了一个约束</p><p>​      *<em>定义方式,与类类似</em></p><pre class="line-numbers language-none"><code class="language-none">// 接口中规范了其中变量的类型interface Person{ //定义接口  readonly name:string;  // 只读属性  age?:number; // 可选属性  sex:string; // 必填属性  [propName:string]:any  //任意属性}/*对象实现了一个接口    对象:必须实现所有的接口属性,*/let obj:Person ={  name:'zs',  age:18,  sex:'male'}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​      <strong>接口就是用代码描述一个对象必须有什么属性（包括方法），但是有没有其他属性就不管了。</strong></p><p>​      <strong>1.声明变量使用接口的时候，变量参数必须和接口中的参数一致，不能多也不能少；</strong></p><p>​      <strong>2.readonly可以在接口中声明只读变量</strong></p><p>​      <strong>3.使用?可以声明一个变量在对象中是可选择的  比如name?: string</strong></p><p>​      <strong>4.[propName:类型]:any   任意属性  propName是一个变量</strong></p><p>​      <strong>一旦定义了任意属性,必填属性和可选属性必须是任意属性的自属性</strong> </p><p>​        <strong>只要propName的类型是string,他对应的值应该是any类型的</strong></p><h4 id="函数的定义"><a href="#函数的定义" class="headerlink" title="函数的定义"></a>函数的定义</h4><p>函数定义</p><p>函数声明,<strong>输入</strong>和<strong>输出</strong>的类型都要定义,有返回值必须规定类型,<strong>没有返回值使用void</strong></p><pre class="line-numbers language-none"><code class="language-none">//函数声明function(n1:number,n2:number) :number{  return  n1+n2}// 函数表达式let f3 = function(n1:number,n2:number):number{  return n1+n2}// 函数的默认值let f4 = function(n1:number=1,n2:number=2):number{  return n1+n2}// 可选参数,参数之后加?表示可选参数,可选参数必须在最后面let f5 = function(n1:number=1,n2?:number=2):number{  return n1+n2}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="接口在函数中的使用"><a href="#接口在函数中的使用" class="headerlink" title="接口在函数中的使用"></a>接口在函数中的使用</h5><p>参数是对象的时候,要对对象中的每个类型进行约束,写在形参的位置非常麻烦,使用接口简化</p><pre class="line-numbers language-none"><code class="language-none">function f6(obj:{id:number,name:string}):number{ //形参十分复杂,使用接口转化  return obj.id}let o = {id:2,name:"zs"}f6(o)//先定义接口,让参数对象实现接口即可interface objName{  id:number;  name:string}function f7(obj:objName):number{  return obj.id}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="接口声明函数"><a href="#接口声明函数" class="headerlink" title="接口声明函数"></a>接口声明函数</h5><pre class="line-numbers language-none"><code class="language-none">nterface&nbsp;SeachFunc{//函数接受两个参数&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;（source:string,subString:string）:boolean}&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;mySearch:SearchFunc;mySearch&nbsp;=&nbsp;function(source:&nbsp;string,subString:string){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;source.search(subString)&nbsp;!==&nbsp;-1&nbsp;&nbsp;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="联合属性在参数中使用"><a href="#联合属性在参数中使用" class="headerlink" title="联合属性在参数中使用"></a>联合属性在参数中使用</h5><p>联合属性在参数中使用,变量必须有两种类型共同的属性</p><pre class="line-numbers language-none"><code class="language-none">//这种定义方式是错误的,返回的是str的length属性,但是定义时有string和number两种属性//str是number时是没有length的,报错function f8(str:string|number):number{  return  str.length}//string和array都有长度function f8(str:string|Array&lt;string&gt;):number{  return  str.length}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="泛型在函数定义中的使用"><a href="#泛型在函数定义中的使用" class="headerlink" title="泛型在函数定义中的使用"></a>泛型在函数定义中的使用</h5><p>泛型,在定义函数或者是接口的时候不定义具体的变量类型,使用的时候在指定类型</p><pre class="line-numbers language-none"><code class="language-none">// 泛型,在定义函数或者是接口的时候不定义具体的变量类型,使用的时候在指定类型function f9(x:string,y:string):string[]{  return [x,y]}function f10(x:number,y:number):number[]{  return [x,y]}//前面两个函数只是变量类型不同,函数工能相同,使用泛型进行定义,简化代码function f11&lt;T&gt;(x:T,y:T):T[] {  return [x,y]}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="剩余参数在函数中的使用"><a href="#剩余参数在函数中的使用" class="headerlink" title="剩余参数在函数中的使用"></a>剩余参数在函数中的使用</h5><pre class="line-numbers language-none"><code class="language-none">//ES6...items在形参中使用,用在最后,拿到的是一个数组function&nbsp;push(array,...items){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;items.forEach(function(item){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;array.push(item)　　})&nbsp;&nbsp;}let&nbsp;a&nbsp;=&nbsp;[];push(a,1,2,3)// 传入第一个参数是一个数组,第二个参数也是一个数组,可以用数组类型function&nbsp;push(array:any[],...items:any[]){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;items.forEach(function(item){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;array.push(item);&nbsp;&nbsp;&nbsp;&nbsp;})&nbsp;&nbsp;}let&nbsp;a&nbsp;=&nbsp;[]push(a,1,2,3)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="undefined和null"><a href="#undefined和null" class="headerlink" title="undefined和null"></a>undefined和null</h3><pre class="line-numbers language-none"><code class="language-none">let&nbsp;udf:&nbsp;undefined&nbsp;=&nbsp;undefinedlet&nbsp;nu:&nbsp;null&nbsp;=&nbsp;null<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>在TS中,undefined和null是任何类型的子类型,所以可以被赋值给其他类型</p><pre class="line-numbers language-none"><code class="language-none">let&nbsp;num3:&nbsp;number&nbsp;|&nbsp;undefined&nbsp;|&nbsp;null&nbsp;=&nbsp;111<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="never"><a href="#never" class="headerlink" title="never"></a>never</h3><p>never:永远不会有返回值的类型</p><p><strong>1,函数抛出异常,永远不会有返回值,类型为never</strong></p><pre class="line-numbers language-none"><code class="language-none">//&nbsp;函数抛出异常,永远不会有返回值,类型为neverlet&nbsp;error&nbsp;=&nbsp;()&nbsp;=&gt;&nbsp;{throw&nbsp;new&nbsp;Error('error')}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>2,死循环函数永远没有返回值,类型为never</strong></p><pre class="line-numbers language-none"><code class="language-none">//&nbsp;死循环函数永远没有返回值,类型为neverlet&nbsp;endless&nbsp;=&nbsp;()&nbsp;=&gt;&nbsp;{while(true)&nbsp;{}}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="void"><a href="#void" class="headerlink" title="void"></a>void</h3><p>js中void操作符可以使任何一个表达式返回undefined</p><pre class="line-numbers language-none"><code class="language-none">void&nbsp;0&nbsp;//&nbsp;将返回undefined<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在TS中,void类型表示没有返回值,没有返回值的函数,他的类型就是void类型</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;TypeScript&quot;&gt;&lt;a href=&quot;#TypeScript&quot; class=&quot;headerlink&quot; title=&quot;TypeScript&quot;&gt;&lt;/a&gt;TypeScript&lt;/h1&gt;&lt;h2 id=&quot;TS的数据类型&quot;&gt;&lt;a href=&quot;#TS的数据类型&quot; class</summary>
      
    
    
    
    <category term="-TypeScript" scheme="https://nwebstone.github.io/categories/TypeScript/"/>
    
    
  </entry>
  
  <entry>
    <title>浏览器工作原理和V8引擎</title>
    <link href="https://nwebstone.github.io/posts/3.html"/>
    <id>https://nwebstone.github.io/posts/3.html</id>
    <published>2022-04-17T05:45:09.000Z</published>
    <updated>2022-04-17T12:24:22.412Z</updated>
    
    <content type="html"><![CDATA[<h1 id="浏览器工作原理和V8引擎"><a href="#浏览器工作原理和V8引擎" class="headerlink" title="浏览器工作原理和V8引擎"></a>浏览器工作原理和V8引擎</h1><p>前端开发最主要的就是<strong>html</strong> 、<strong>css</strong>、<strong>JavaScript</strong></p><p>Javascript是非常重要的</p><p>JavaScript是Vue、React、Angular、uniapp、taro、ReactNative的基础</p><h2 id="Javascript应用"><a href="#Javascript应用" class="headerlink" title="Javascript应用"></a>Javascript应用</h2><p>Web开发：React、Vue 、Angular</p><p>移动端开发:Reactive、Weex</p><p>小程序开发：微信小程序、支付宝小程序、uniapp、taro</p><p>桌面应用开发：Electron</p><p>后端开发：Node环境，比如express、koa、egg.js</p><h2 id="TypeScript会不会替代JavaScript"><a href="#TypeScript会不会替代JavaScript" class="headerlink" title="TypeScript会不会替代JavaScript??"></a>TypeScript会不会替代JavaScript??</h2><p>JavaScript是不会对变量进行检测，所以有很多方案，flow，TypeScript给js带来了类型检测的思想。</p><p>JavaScript是不会被替代的。</p><h2 id="语言分发展"><a href="#语言分发展" class="headerlink" title="语言分发展"></a>语言分发展</h2><p><strong>JS是一门高级的编程语言</strong></p><p>机器语言===》汇编语言===》高级语言（C 、C++、Java、JavaScript、Python</p><p>高级语言计算机是不认识的，需要将高级语言转变为机器指令</p><p><strong>计算机语言运行的过程</strong>:高级语言===》汇编语言===》机器语言</p><p>高级语言又可以分为解释型语言和编译型语言</p><p>C、C++是先将代码编译为可执行文件，是一种编译型语言</p><p>JS、Python是解释型语言</p><h2 id="JS是如何在浏览器中执行"><a href="#JS是如何在浏览器中执行" class="headerlink" title="JS是如何在浏览器中执行"></a>JS是如何在浏览器中执行</h2><p>node和浏览器中都已js的解析引擎</p><h3 id="浏览器下载资源的过程"><a href="#浏览器下载资源的过程" class="headerlink" title="浏览器下载资源的过程"></a><strong>浏览器下载资源的过程</strong></h3><p>在浏览器中输入 域名==》DNS解析为ip地址（服务器的地址）==》服务器会返回一个index.html网页</p><p>==》浏览器会对浏览器进行解析==&gt;在解析html的过程中会遇到html、css、script，下载相应的资源</p><p>===》执行相应的资源的解析</p><h3 id="浏览器的内核"><a href="#浏览器的内核" class="headerlink" title="浏览器的内核"></a><strong>浏览器的内核</strong></h3><p>不同浏览器会又不同的内核</p><p>GecKo:早期被NetScope和Mozilla、Firefox使用</p><p>Trident:微软开发，被IE4-IE11浏览器使用，但是Edge浏览器已经转向Blink</p><p>Webkit:苹果基于KHTML开发、开源，用与Safari，Chrome之前也进行使用</p><p>Blink:是WebKit的一个分支，Google开发，目前应用于Google Chrome、Edge、Opera浏览器</p><p><strong>常说的浏览器内核指的是浏览器的排版引擎</strong></p><p>排版引擎（layout engine)，也称为浏览器引擎（browser engine)、页面渲染引擎（rendering engine)</p><h3 id="浏览器的渲染过程"><a href="#浏览器的渲染过程" class="headerlink" title="浏览器的渲染过程"></a>浏览器的渲染过程</h3><h4 id="loader"><a href="#loader" class="headerlink" title="loader"></a>loader</h4><p>　Loader模块负责处理所有的HTTP请求以及网络资源的缓存，相当于是从URL输入到Page Resource输出的变换过程。HTML页面中通常有外链的JS/CSS/Image资源，为了不阻塞后续解析过程，一般会有两个IO管道同时存在，一个负责主页面下载，一个负责各种外链资源的下载。</p><p><img src="C:\Users\admin\AppData\Roaming\Typora\typora-user-images\1650181674551.png" alt="1650181674551"></p><p>　注意：虽然大部分情况下不同资源可以并发下载异步解析（如图片资源可以在主页面解析显示完成后再被显示），但JS脚本可能会要求改变页面，因此有时保持执行顺序和下载管道后续处理的阻塞是不可避免的</p><h4 id="渲染过程"><a href="#渲染过程" class="headerlink" title="渲染过程"></a>渲染过程</h4><p>1、浏览器首先下载下来的是html,浏览器内核中的html parser将html转变为DOM树。</p><p>​    <strong>注意：</strong>DOM形成之后，JavaScript可以对DOM进行操作 </p><p>​    同时css样式也会被css parser进行解析成为css rules</p><p>​    DOM tree + css rules  形成render tree</p><p><img src="C:\Users\admin\AppData\Roaming\Typora\typora-user-images\1650177904184.png" alt="1650177904184"></p><p>2、layout计算（根据浏览器的大小和状态），计算出最终的render tree</p><p>3、painting</p><p>4、display    </p><p><img src="C:\Users\admin\AppData\Roaming\Typora\typora-user-images\1650181343218.png" alt="1650181343218"></p><p><img src="C:\Users\admin\AppData\Roaming\Typora\typora-user-images\1650181359587.png" alt="1650181359587"></p><p><strong>jS代码可能对dom进行操作，可能发起请求，所以在生成dom之后会执行js</strong></p><h3 id="JS引擎"><a href="#JS引擎" class="headerlink" title="JS引擎"></a>JS引擎</h3><p>高级语言==》浏览器和node==》最终仍然是被计算机所执行</p><p>但是CPU只认识自己的指令集，实际上是机器语言，才能被CPU执行</p><p>JS引擎：将JS转换为机器语言</p><h4 id="常见的JS引擎："><a href="#常见的JS引擎：" class="headerlink" title="常见的JS引擎："></a>常见的JS引擎：</h4><p>SpiderMonkey:收款JS引擎</p><p>Chakra:微软开发，用于IT浏览器</p><p>JSCore：WebKit中的JS浏览器</p><p>V8引擎：Google开发的</p><h4 id="JS引擎与浏览器内核的关系"><a href="#JS引擎与浏览器内核的关系" class="headerlink" title="JS引擎与浏览器内核的关系"></a>JS引擎与浏览器内核的关系</h4><p>V8引擎是使用C++编写的，开源的高性能的JS和WebAssembly引擎，用于Chrome和Node.js等</p><p>实现ECMAScript和WebAssembly，并在Windows7或者更高版本使用，mac OS10.12+</p><h4 id="JS引擎解析过程描述"><a href="#JS引擎解析过程描述" class="headerlink" title="JS引擎解析过程描述"></a><strong>JS引擎解析过程描述</strong></h4><p>JS===&gt;V8引擎Parser解析(词法分析和语法分析===》解析成ast树（抽象语法树）</p><p>​                                                                                ===》ignition<strong>转变为字节码</strong>==》执行</p><p>词法分析：将关键字，标识符，变量进行解析称号对象形式</p><pre class="line-numbers language-none"><code class="language-none">const name = 'zs'将词解析为tokens:[{type:"keyword",value:"const"},{type:"identifier",value:"name"}.....]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>ast树可以被<strong>ignition</strong>被转换为<strong>字节码</strong></p><h4 id="JS代码为什么不能直接转变为机器指令而是转变为字节码？？"><a href="#JS代码为什么不能直接转变为机器指令而是转变为字节码？？" class="headerlink" title="JS代码为什么不能直接转变为机器指令而是转变为字节码？？"></a><strong>JS代码为什么不能直接转变为机器指令而是转变为字节码？？</strong></h4><p>字节码是<strong>跨平台的</strong>，在任何一个平台再将字节码转变为汇编指令，再转变为机器指令，运行</p><p><strong>一个函数，如果多次执行，每次指向都要进行由字节码到汇编指令，再转变为机器指令的过程，很浪费性能，如何进行解决？？</strong></p><p>V8引擎中<strong>TurboFan</strong>会收集信息，将多次执行的代码标记为<strong>hot</strong>，将这些代码转变的机器指令存储起来，下次执行时可以方便调用。</p><p>如果一个函数或者时方法前后两次传递的参数类型不一致，V8引擎中有<strong>Deoptimization</strong>，将之前保存的<strong>函数机器指令再次转变为字节码，重新转换机器指令，进行执行</strong>，相当V8引擎进行代码优化。</p><p><strong>如果编写的时TypeScript代码，指向效率会比原生的JS语法高，因为规定了相应的数据类型</strong></p><p><img src="C:\Users\admin\AppData\Roaming\Typora\typora-user-images\1650181555415.png" alt="1650181555415"></p><h4 id="抽象语法树的应用"><a href="#抽象语法树的应用" class="headerlink" title="抽象语法树的应用"></a><strong>抽象语法树的应用</strong></h4><p>babel：ts==》ast树==》generate code ==&gt;js代码</p><p>vue中的中渲染结构==》最终都是执行的render函数==》template==&gt;要将html字符串转变为结构，</p><p>​            字符串==》ast树==》VS Node==》html结构</p><h4 id="JS的预解析过程"><a href="#JS的预解析过程" class="headerlink" title="JS的预解析过程"></a>JS的预解析过程</h4><p>Bink将源码交给V8引擎，Stream获取到源码并且进行编码转换</p><p>Scanner会对源码进行词法解析，词法分析会将代码解析成为tokens</p><p>接下来tokens会被转化称为sat树,经过PreParser和Parser:</p><p>​        1.Parser就是直接将tokens转变为ast树</p><p>​        2.PreParser称之为预解析,为什么需要进行预解析</p><p>​         这是因为并不是所有的JS代码，在一开始的时候就会被执行，如果对所有的js代码都解析会影响网页的运行效率。</p><p>​         V8引擎实现类Lazy Parsing(延迟解析)，作用是将暂时不必要的函数进行预解析，也就是说只解析暂时需要的内容，而对函数的全量解析在函数被调用的时候才会进行。</p><pre class="line-numbers language-none"><code class="language-none">function outer(){function inner(){console.log('inner')}}outer()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>outer内部定义了inner函数，但是inner函数没有被调用，所以只会对其进行预解析</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>JS的重要性</p><p>浏览器的工作原理</p><p>使用到V8引擎中的loader,parser,Ignition，turboFan等模块</p><p><img src="C:\Users\admin\AppData\Roaming\Typora\typora-user-images\1650182113891.png" alt="1650182113891"></p><h1 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h1><h3 id="全局变量的解析过程"><a href="#全局变量的解析过程" class="headerlink" title="全局变量的解析过程"></a>全局变量的解析过程</h3><pre class="line-numbers language-none"><code class="language-none">var name = 'zs'var num1 = 20var num2 = 30var result = num1+num2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>解析过程</strong></p><p>  1、代码解析</p><p>​     a.在进行解析之前V8引擎在堆内存中会创建一个**globalObject对象（全局对象Go)**，会有String,Date,Number…全局内容）</p><p>​    b.在这个对象中有一个<strong>window属性</strong>，这个属性<strong>指向globalObject(自己的属性指向自己)</strong></p><p>​    c.解析代码时候，会将全局的<strong>属性挂载到全局对象当中，但是这个属性是没有值的,全部都是undefined</strong></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">//以一段伪代码表示</span><span class="token comment">// 伪代码,此时函数还没有执行</span><span class="token keyword">var</span> globalObject<span class="token operator">=</span> <span class="token punctuation">{</span>  String<span class="token operator">:</span><span class="token string">"类"</span><span class="token punctuation">,</span>  Date<span class="token operator">:</span><span class="token string">"类"</span><span class="token punctuation">,</span>  setTimeout<span class="token operator">:</span><span class="token string">"函数"</span><span class="token punctuation">,</span>  name<span class="token operator">:</span><span class="token keyword">undefined</span><span class="token punctuation">,</span>  num1<span class="token operator">:</span><span class="token keyword">undefined</span><span class="token punctuation">,</span>  result<span class="token operator">:</span><span class="token keyword">undefined</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>  <strong>此时,在函数定义之打印变量的值,会得到undefined,但不会报错</strong></p><p>2、运行代码</p><p>​    a.为了执行代码，V8引擎会创建<strong>执行上下文栈（函数调用栈）</strong>（Executions Context Stack  ECSSstack）</p><p>​      代码运行会先从磁盘加载到内存中，会对内存进行划分，一个是栈结构，一个是堆结构。</p><p>​      代码想要执行的时候需要放到执行上下文栈中进行执行，执行完之后弹出栈。</p><p>​    b.一般执行上下文栈式放的是函数的，为了全局代码能够执行，会创建<strong>全局执行上下文</strong>（Global Execution Context Stack  <strong>GEC</strong>)</p><p>​      这里的代码不是函数,为了执行这些代码,会创建全局执行上下文</p><p>​       全局执行上下文就可以放入到执行上下文栈中进行执行</p><p>​       <strong>全局执行上下文中维护的是VO(variable Object 变量对象),VO指向的是GO</strong></p><p>​    *<em>依次执行代码**</em></p><p><img src="F:\桌面文件\Snipaste_2022-04-17_18-30-22.jpg"></p><h3 id="函数的解析"><a href="#函数的解析" class="headerlink" title="函数的解析"></a>函数的解析</h3><p> 1.解析过程</p><p>​    a.V8创建全局对象,将name添加到GO中</p><p>​    b.编译解析过程是不会执行函数的,所以就跳过foo(),继续向后编译</p><p>​    c.遇到函数定义之后,将foo属性中添加到GO中,<strong>V8此时会开辟一块内存空间(有一个内存地址,比如0xa00),存储函数</strong></p><p>​    这个空间主要包括两部分,一个是<strong>父级作用域</strong>,就是函数的上一层作用域,另一部分保存<strong>函数的函数体</strong></p><p>​    <strong>GO中foo属性对应的是函数的地址</strong></p><p>  2.执行过程</p><p>​    a.var name= ‘zs’,通过VO找到GO,更改值</p><p>​    b.指向到foo(),<strong>通过VO找到GO中的foo==&gt;对应的函数地址====&gt;此时创建函数执行上下文(Functiona Execution Context  FEC)</strong></p><p>​      函数执行上下文中也有一个VO,这个VO指向的是<strong>AO(Activation Object)</strong></p><p>​      在函数执行之前会创建AO,<strong>AO存放的是函数内部定义的变量,作用类似于GO,AO中的变量开始也是undefined,函数执行完毕后,函数的</strong></p><p>​      执行上下文弹出,会被销毁掉,如果再次执行上下文会再次创建函数执行上下文</p><pre class="line-numbers language-none"><code class="language-none">//函数解析示例var name="zs"foo()function foo() {  console.log("foo");}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="F:\桌面文件\函数解析过程.jpg" alt="函数解析过程"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;浏览器工作原理和V8引擎&quot;&gt;&lt;a href=&quot;#浏览器工作原理和V8引擎&quot; class=&quot;headerlink&quot; title=&quot;浏览器工作原理和V8引擎&quot;&gt;&lt;/a&gt;浏览器工作原理和V8引擎&lt;/h1&gt;&lt;p&gt;前端开发最主要的就是&lt;strong&gt;html&lt;/strong</summary>
      
    
    
    
    <category term="-JavaScript" scheme="https://nwebstone.github.io/categories/JavaScript/"/>
    
    
    <category term="-JS进阶" scheme="https://nwebstone.github.io/tags/JS%E8%BF%9B%E9%98%B6/"/>
    
  </entry>
  
  <entry>
    <title>HTML_01</title>
    <link href="https://nwebstone.github.io/posts/2.html"/>
    <id>https://nwebstone.github.io/posts/2.html</id>
    <published>2022-04-17T01:24:00.000Z</published>
    <updated>2022-04-17T03:14:44.455Z</updated>
    
    <content type="html"><![CDATA[<h1 id="HTML-01"><a href="#HTML-01" class="headerlink" title="HTML_01"></a>HTML_01</h1><h2 id="网页"><a href="#网页" class="headerlink" title="网页"></a>网页</h2><h3 id="什么是网页？"><a href="#什么是网页？" class="headerlink" title="什么是网页？"></a>什么是网页？</h3><p>网站是指在因特网上根据一定的规则，使用 HTML 等制作的用于展示特定内容相关的网页集合。</p><p>网页是网站中的一“页”，通常是 HTML 格式的文件，它要通过浏览器来阅读。</p><p><strong>网页是构成网站的基本元素</strong>，它通常由图片、链接、文字、声音、视频等元素组成。通常我们看到的网页，<br>常见以 .<strong>htm</strong> 或 <strong>.html</strong> 后缀结尾的文件，因此将其俗称为 HTML 文件。</p><h2 id="常用浏览器"><a href="#常用浏览器" class="headerlink" title="常用浏览器"></a>常用浏览器</h2><p>浏览器最主要的部分是浏览器内核，负责读取网页内容，整理讯息，计算网页的显示方式并显示页面。</p><table><thead><tr><th>浏览器</th><th>内核</th><th>备注</th></tr></thead><tbody><tr><td>IE</td><td>Trident</td><td>IE、360极速浏览器、百度浏览器</td></tr><tr><td>Firefox</td><td>Gecko</td><td>火狐浏览器内核</td></tr><tr><td>Safari</td><td>Webkit</td><td>苹果浏览器内核</td></tr><tr><td>Chrome/Opera</td><td>Bink</td><td>Chrome/Opera浏览器内核，Bink其实是WebKit的分支</td></tr></tbody></table><h1 id="Web标准"><a href="#Web标准" class="headerlink" title="Web标准"></a>Web标准</h1><p>Web 标准是由 <strong>W3C 组织</strong>和其他标准化组织制定的一系列标准的集合。<strong>W3C（万维网联盟）</strong>是国际最著名的标准化组织。</p><h2 id="为什么指定Web标准？"><a href="#为什么指定Web标准？" class="headerlink" title="为什么指定Web标准？"></a>为什么指定Web标准？</h2><p>不同的浏览器解析相同的html文件会有差异。</p><p><strong>制定web标准的优点</strong>：使网站便于维护，网页内容能够被更加广泛的设备访问。</p><h2 id="Web标准的构成"><a href="#Web标准的构成" class="headerlink" title="Web标准的构成"></a>Web标准的构成</h2><p>一个页面主要有三部分组成：结构、样式和行为，分别对应前端必备技术，html，css，javascipt</p><table><thead><tr><th>标准</th><th>说明</th></tr></thead><tbody><tr><td>结构（html）</td><td>搭建网页的基本结构，实现网页的布局</td></tr><tr><td>样式（css)</td><td>用于美化页面，网页元素的大小，颜色，样式</td></tr><tr><td>行为（javascript)</td><td>实现网页的动态效果和页面与用户的交互行为</td></tr></tbody></table><h2 id="HTML基本标签"><a href="#HTML基本标签" class="headerlink" title="HTML基本标签"></a>HTML基本标签</h2><p>html页面中的基本标签结构</p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span><span class="token punctuation">&gt;</span></span>   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">&gt;</span></span>标题<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">&gt;</span></span>    主要内容  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在使用vscode时，使用<strong>！+tab</strong>可以自动给创建html文件的表头</p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token comment">&lt;!-- 文档类型的声名，告诉浏览器使用哪种HTML版本来显示网页，文档类型声名在最前面 --&gt;</span><span class="token doctype"><span class="token punctuation">&lt;!</span><span class="token doctype-tag">DOCTYPE</span> <span class="token name">html</span><span class="token punctuation">&gt;</span></span><span class="token comment">&lt;!-- 定义当前文档显示的语言 en是英语 zh-CN是中文网页 --&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span> <span class="token attr-name">lang</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>en<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">&gt;</span></span>  <span class="token comment">&lt;!-- 定义使用哪种字符编码 --&gt;</span>  <span class="token comment">&lt;!-- 常用的字符编码格式：GB2312，BIG5,GBK，UTF-8(万国码)最常用 --&gt;</span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>UTF-8<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>  <span class="token comment">&lt;!-- 兼容性 --&gt;</span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">http-equiv</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>X-UA-Compatible<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>IE=edge<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>  <span class="token comment">&lt;!-- 视口 --&gt;</span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>viewport<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>width=device-width, initial-scale=1.0<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">&gt;</span></span>标题<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">&gt;</span></span>     主要内容<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="HTML常用标签"><a href="#HTML常用标签" class="headerlink" title="HTML常用标签"></a>HTML常用标签</h2><p>标签具有语义化可以是页面的结构更加的清晰</p><h3 id="h标签"><a href="#h标签" class="headerlink" title="h标签"></a>h标签</h3><p>h是head的缩写，标题标签，共有六个等级，从<strong>h1</strong>到<strong>h6</strong>依次减小</p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h1</span><span class="token punctuation">&gt;</span></span>标题内容<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h1</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>主要</strong>：在h标签中文字会加粗变大，<strong>一个标签独占一行</strong></p><h3 id="p标签"><a href="#p标签" class="headerlink" title="p标签"></a>p标签</h3><p>p是paragraph的缩写，段落标签，在标签内的为你单独为一个段落。</p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">&gt;</span></span>这是一个段落标签<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>注意：</strong>段落中的文字会根究浏览器窗口的大小自动换行，段落与段落之间会有空隙。</p><h3 id="br标签"><a href="#br标签" class="headerlink" title="br标签"></a>br标签</h3><p>网页中的文本只有在到达浏览器右端的时候才能进行自动换行，如果希望某段文本进行强制换行可以使用br标签</p><pre class="line-numbers language-none"><code class="language-none">&lt;br /&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>注意</strong>：br标签是一个单标签，br标签换行之后的文本上下是没有空袭的，段落标签换行后会形成两个段落，上下两个段落之间会有一定的空隙。</p><h3 id="文本格式化标签"><a href="#文本格式化标签" class="headerlink" title="文本格式化标签"></a>文本格式化标签</h3><p>文本格式化标签就是给文本添加一定样式的标签。</p><table><thead><tr><th>语义</th><th>标签</th><th>说明</th></tr></thead><tbody><tr><td>加粗</td><td><strong></strong>或者是<b></b></td><td>strong标签语义更加强烈</td></tr><tr><td>倾斜</td><td><em></em>或者<i><i></i></i></td><td><strong>经常全局曲消倾斜，用i标签放置小图标</strong></td></tr><tr><td>删除线</td><td><del></del>或者<s><s></s></s></td><td>del标签语义更加强烈</td></tr><tr><td>下划线</td><td><ins></ins>或者<u></u></td><td>ins标签语义更加强烈</td></tr></tbody></table><h3 id="div与span标签"><a href="#div与span标签" class="headerlink" title="div与span标签"></a>div与span标签</h3><p><strong>div：是用来进行布局的，但是一行只能放一个</strong></p><p><strong>span：用于布局，一行可以有多个span标签</strong></p><p>这里只简单了解一些两个标签不同，后面会详细说明。</p><h3 id="图像标签"><a href="#图像标签" class="headerlink" title="图像标签"></a>图像标签</h3><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token comment">&lt;!--img标签用于定义页面中的图像--&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>img</span>      <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>图片存放的路径<span class="token punctuation">"</span></span>      <span class="token attr-name">alt</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>加载不出来时显示文本<span class="token punctuation">"</span></span>      <span class="token attr-name">title</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span>“鼠标经过之后会显示图片的标题”</span>     <span class="token attr-name">width</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span>“100px”</span> <span class="token attr-name">设置宽度</span>     <span class="token attr-name">height</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>100px<span class="token punctuation">"</span></span> <span class="token attr-name">设置高度</span>     <span class="token attr-name">border</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span>“1px”</span> <span class="token attr-name">设置边框</span><span class="token punctuation">/&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="相对路径与绝对路径"><a href="#相对路径与绝对路径" class="headerlink" title="相对路径与绝对路径"></a>相对路径与绝对路径</h3><p>相对路径：相对于当前文件的路径来说的，写路径的时候从当前路径开始写</p><p><strong>./表示当前路径</strong></p><p><strong>../表示上一级路径</strong></p><p>绝对路径：从磁盘的根路径开始找 比如c:/……</p><p><strong>绝对路径的缺点:如果将文件发给别人使用,会找不到资源</strong></p><h1 id="a标签"><a href="#a标签" class="headerlink" title="a标签"></a>a标签</h1><p>超链接标签</p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token comment">&lt;!--_blnk在新的页面打开链接_self在当前页面打开链接herf链接可以是外部链接如www.baidu.com可以是空链接 herf="#"可以是内部的链接 herf="index.html"--&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">herf</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>点击之后要跳转的链接<span class="token punctuation">"</span></span> <span class="token attr-name">target</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>_blank/_self<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>文本\图像\表格<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="标签中的特殊字符"><a href="#标签中的特殊字符" class="headerlink" title="标签中的特殊字符"></a>标签中的特殊字符</h3><p><img src="C:\Users\admin\AppData\Roaming\Typora\typora-user-images\1650164110538.png" alt="1650164110538"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;HTML-01&quot;&gt;&lt;a href=&quot;#HTML-01&quot; class=&quot;headerlink&quot; title=&quot;HTML_01&quot;&gt;&lt;/a&gt;HTML_01&lt;/h1&gt;&lt;h2 id=&quot;网页&quot;&gt;&lt;a href=&quot;#网页&quot; class=&quot;headerlink&quot; title=&quot;网</summary>
      
    
    
    
    <category term="-HTML" scheme="https://nwebstone.github.io/categories/HTML/"/>
    
    
  </entry>
  
  <entry>
    <title>02-博客诞生</title>
    <link href="https://nwebstone.github.io/posts/1.html"/>
    <id>https://nwebstone.github.io/posts/1.html</id>
    <published>2022-04-16T19:10:51.000Z</published>
    <updated>2022-04-17T03:23:02.427Z</updated>
    
    <content type="html"><![CDATA[<h1 id="博客诞生"><a href="#博客诞生" class="headerlink" title="博客诞生"></a>博客诞生</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;博客诞生&quot;&gt;&lt;a href=&quot;#博客诞生&quot; class=&quot;headerlink&quot; title=&quot;博客诞生&quot;&gt;&lt;/a&gt;博客诞生&lt;/h1&gt;</summary>
      
    
    
    
    <category term="-生活" scheme="https://nwebstone.github.io/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
  </entry>
  
  <entry>
    <title>博客与博主</title>
    <link href="https://nwebstone.github.io/posts/1.html"/>
    <id>https://nwebstone.github.io/posts/1.html</id>
    <published>2021-05-27T13:00:00.000Z</published>
    <updated>2022-04-16T19:36:26.933Z</updated>
    
    <content type="html"><![CDATA[<p>相遇皆是缘分</p><h3 id="为什么建博客？"><a href="#为什么建博客？" class="headerlink" title="为什么建博客？"></a>为什么建博客？</h3><p>肿么说了! 纯属个人兴趣，好玩，唉，就是玩!嘻嘻! 会有些成就感吧,拥有一个自己的博客写一些自己感兴趣的事或物,不是一件很酷的事嘛!</p><h3 id="展望博客"><a href="#展望博客" class="headerlink" title="展望博客"></a>展望博客</h3><p>我会整理一些个人所学的知识（学前端的，也会捣鼓捣鼓一些其它的专业的知识）或生活方面有兴趣的事发到博客上供大家观摩</p><h3 id="关于博主"><a href="#关于博主" class="headerlink" title="关于博主"></a>关于博主</h3><p>有位可爱的（小）朋友，给我取名叫 “仙气”，这是也是我博客上自居 “仙气” 的由来。喜欢自己所喜欢的，做自己想做的，追求自由与潇洒，多酷啊！ 想法是美好的，可现实… …   给大家推荐一首诗吧</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"> 《自由与爱情》---作者:裴多菲​ 生命诚可贵​ 爱情价更高​ 若为自由故​ 二者皆可抛<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>溜溜球啦！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;相遇皆是缘分&lt;/p&gt;
&lt;h3 id=&quot;为什么建博客？&quot;&gt;&lt;a href=&quot;#为什么建博客？&quot; class=&quot;headerlink&quot; title=&quot;为什么建博客？&quot;&gt;&lt;/a&gt;为什么建博客？&lt;/h3&gt;&lt;p&gt;肿么说了! 纯属个人兴趣，好玩，唉，就是玩!嘻嘻! 会有些成就感吧,拥有</summary>
      
    
    
    
    
  </entry>
  
</feed>
