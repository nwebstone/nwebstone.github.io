{"meta":{"title":"ZY_LHC的博客","subtitle":"ZYLHCの博客","description":"博客因兴趣诞生,在不断完善中","author":"ZYLHC","url":"https://nwebstone.github.io","root":"/"},"pages":[{"title":"留言板","date":"2020-10-31T02:11:28.000Z","updated":"2021-11-23T10:50:01.880Z","comments":false,"path":"comments/index.html","permalink":"https://nwebstone.github.io/comments/index.html","excerpt":"","text":""},{"title":"关于本站","date":"2022-04-16T04:58:56.000Z","updated":"2022-04-16T18:01:10.639Z","comments":false,"path":"about/index.html","permalink":"https://nwebstone.github.io/about/index.html","excerpt":"","text":"仙气の云彩“ 认识自我、超越自我 “ 那么你离成功就又进了一步！ 当你在项目中感觉所要学习的人和事越来越多时，说明你在 成长 。 当你感觉要责怪的人和事越来越少时，说明你在 成熟 。 当你在项目中不断获得了友谊和朋友时，说明你将取得项目的 成功 。 联系我B站：bili_1423268583（萌新up） QQ：1601507099（嘀嘀~，麻烦让一下，我要开车了！） 座右铭：既然选择了远方 便只顾风雨兼程"},{"title":"archives","date":"2019-10-24T16:00:00.000Z","updated":"2021-06-27T12:40:24.587Z","comments":true,"path":"archives/index.html","permalink":"https://nwebstone.github.io/archives/index.html","excerpt":"","text":""},{"title":"分类","date":"2020-11-24T07:12:19.000Z","updated":"2021-07-26T14:44:28.785Z","comments":false,"path":"categories/index.html","permalink":"https://nwebstone.github.io/categories/index.html","excerpt":"","text":""},{"title":"我的歌单","date":"2019-05-17T08:14:00.000Z","updated":"2021-07-26T13:06:52.537Z","comments":true,"path":"music/index.html","permalink":"https://nwebstone.github.io/music/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2018-06-07T14:17:49.000Z","updated":"2021-07-27T07:31:10.990Z","comments":true,"path":"link/index.html","permalink":"https://nwebstone.github.io/link/index.html","excerpt":"","text":""},{"title":"标签","date":"2020-11-24T07:14:39.000Z","updated":"2021-07-26T14:44:42.337Z","comments":false,"path":"tags/index.html","permalink":"https://nwebstone.github.io/tags/index.html","excerpt":"","text":""},{"title":"相册","date":"2022-04-16T19:33:07.651Z","updated":"2021-10-14T02:13:24.113Z","comments":false,"path":"List/gallery/index.html","permalink":"https://nwebstone.github.io/List/gallery/index.html","excerpt":"","text":"壁紙 世俗的欲望 OH MY GIRL 關於OH MY GIRL的圖片"},{"title":"","date":"2019-08-10T08:41:10.000Z","updated":"2022-04-16T19:01:50.785Z","comments":false,"path":"List/movies/index.html","permalink":"https://nwebstone.github.io/List/movies/index.html","excerpt":"","text":"励志视频"},{"title":"Music-BBOX","date":"2020-04-23T04:58:56.000Z","updated":"2022-04-16T18:57:18.725Z","comments":false,"path":"List/music/index.html","permalink":"https://nwebstone.github.io/List/music/index.html","excerpt":"","text":""},{"title":"","date":"2021-09-28T14:56:14.000Z","updated":"2021-09-28T16:44:43.445Z","comments":false,"path":"List/gallery/ohmygirl/index.html","permalink":"https://nwebstone.github.io/List/gallery/ohmygirl/index.html","excerpt":"","text":""},{"title":"","date":"2021-09-28T14:56:13.000Z","updated":"2021-10-14T02:11:35.135Z","comments":false,"path":"List/gallery/wallpaper/index.html","permalink":"https://nwebstone.github.io/List/gallery/wallpaper/index.html","excerpt":"","text":""}],"posts":[{"title":"深拷贝与浅拷贝","slug":"深拷贝与浅拷贝","date":"2022-04-18T15:14:53.000Z","updated":"2022-04-28T06:09:34.501Z","comments":true,"path":"posts/8.html","link":"","permalink":"https://nwebstone.github.io/posts/8.html","excerpt":"","text":"为什么出现深浅拷贝？由于JS对基本类型和引用类型的处理不同。基本类型指的是简单的数据段，而引用类型指的是一个对象，而JS不允许我们直接操作内存中的地址，也就是不能操作对象的内存空间，所以，我们对对象的操作都只是在操作它的引用而已。 JS中的变量赋值当我们复制一个基本类型的值时，会创建一个新值，并把它保存在新的变量的位置上。而如果我们复制一个引用类型时，同样会把变量中的值复制一份放到新的变量空间里，但此时复制的东西（也就是值）并不是对象本身，而是指向该对象的指针。所以我们复制引用类型后，两个变量其实指向同一个对象，改变其中一个对象，会影响到另外一个。 var num = 20; var num2 = num; //num2 20 但是num1和num2的内存地址不同 var obj = { name: 'hello' } var obj2 = obj; // obj和obj2的内存地址是相同的 obj.name = 'zs; obj2.name; // 'zs' var num2 = num; 属于基本类型的复制，直接在栈内存中创建了一块新内存空间给num2，存的值同样是20，num2和num完全无关，而var obj2 = obj因为obj是一个对象，所以属于引用类型的复制，所以此时复制给obj2的只是原先保存在obj变量中的引用地址（指针）而已，此操作过后，obj和obj2两个变量存的都是堆内存那个实际对象的引用地址，两个变量指向了同一个内存空间。 深拷贝与浅拷贝深浅拷贝一般用于引用类型的复制，不用于基本类型复制。 浅拷贝只复制了引用而未真正复制值，没有开新的内存空间s 1、“ = ”运算符const originArray = [1,2,3,4,5]; const originObj = {a:'a',b:'b',c:[1,2,3],d:{dd:'dd'}}; const cloneArray = originArray; //指向同一个内存地址 const cloneObj = originObj; //指向同一个内存地址 console.log(cloneArray); // [1,2,3,4,5] console.log(originObj); // {a:'a',b:'b',c:Array[3],d:{dd:'dd'}} cloneArray.push(6); cloneObj.a = {aa:'aa'}; console.log(cloneArray); // [1,2,3,4,5,6] console.log(originArray); // [1,2,3,4,5,6] console.log(cloneObj); // {a:{aa:'aa'},b:'b',c:Array[3],d:{dd:'dd'}} console.log(originArray); // {a:{aa:'aa'},b:'b',c:Array[3],d:{dd:'dd'}} 深拷贝深拷贝就是对目标的完全拷贝，不像浅拷贝那样只是复制了一层引用，就连值也都复制了，只要进行了深拷贝，它们老死不相往来，谁也不会影响谁。 1、利用 JSON 对象中的 parse 和 stringify//数组 const arr1 =[1,2,3,4,5] const arr2 =JSON.parse(JSON.stringify(arr1)) //深拷贝 console.log(arr2) //[1,2,3,4,5] arr1.push(6) console.log(arr1) //[1,2,3,4,5,6] //添加了6 console.log(arr2) //[1,2,3,4,5] 还是原先的值，两者不相关 //对象 const originObj = {a:'a',b:'b',c:[1,2,3],d:{dd:'dd'}}; const cloneObj = JSON.parse(JSON.stringify(originObj)); console.log(cloneObj === originObj); // false cloneObj.a = 'aa'; cloneObj.c = [1,1,1]; cloneObj.d.dd = 'doubled'; console.log(cloneObj); // {a:'aa',b:'b',c:[1,1,1],d:{dd:'doubled'}}; console.log(originObj); // {a:'a',b:'b',c:[1,2,3],d:{dd:'dd'}}; 注意： JSON.parse/stringify在遇到函数、undefined、Symbol、new Date、正则等时会丢失，无法对上述几种情况进行正常复制，所以当遇到要复制的对象中包含函数的时候，就不能使用JSON.parse/stringify进行深拷贝了。 2、利用递归来实现每一层都重新创建对象并赋值function deepClone(source){ const targetObj = source.constructor === Array ? [] : {}; // 判断复制的目标是数组还是对象 for(let keys in source){ // 遍历目标 if(source.hasOwnProperty(keys)){ if(source[keys] &amp;&amp; typeof source[keys] === 'object'){ // 如果值是对象，就递归一下 targetObj[keys] = source[keys].constructor === Array ? [] : {}; targetObj[keys] = deepClone(source[keys]); }else{ // 如果不是，就直接赋值 targetObj[keys] = source[keys]; } } } return targetObj; } 首层深拷贝1、数组的concat（）方法concat 只是对数组的第一层进行深拷贝。 concat() 方法用于连接两个或多个数组。该方法不会改变现有的数组，而仅仅会返回被连接数组的一个副本。 var a = [1,2,3]; console.log(a.concat(4,5)); // a = [1,2,3,4,5] -------------------简单情况都是基本类型时------------------ const originArray = [1,2,3,4,5]; //一层数组 const cloneArray = originArray.concat(); // 返回一个新的数组，两者内存空间不同 console.log(cloneArray === originArray); // false cloneArray.push(6); // [1,2,3,4,5,6] console.log(originArray); [1,2,3,4,5]; ----------------------------有引用类型时--------------------------------- const originArray = [1,[1,2,3],{a:1}]; //多层数组 const cloneArray = originArray.concat(); console.log(cloneArray === originArray); // false cloneArray[0]=2; console.log(cloneArray) // [2,[1,2,3],{a:1}]; console.log(originArray) // [1,[1,2,3],{a:1}]; 修改cloneArray的第一个值不影响原数组 cloneArray[1].push(4); cloneArray[2].a = 2; console.log(originArray); // [1,[1,2,3,4],{a:2}] //修改cloneArray的数组和对象值时会影响原数组，说明两者的引用是同一个 2、slice-------------------简单情况都是基本类型时------------------ const originArray = [1,2,3,4,5]; const cloneArray = originArray.slice(); console.log(cloneArray === originArray); // false cloneArray.push(6); // [1,2,3,4,5,6] console.log(originArray); [1,2,3,4,5]; //两者互不干扰，是深拷贝 -------------------有引用类型时------------------ const originArray = [1,[1,2,3],{a:1}]; const cloneArray = originArray.slice(); console.log(cloneArray === originArray); // false cloneArray[0] =2; //修改克隆数组的第一个值 console.log(cloneArray) // [2,[1,2,3],{a:1}]; console.log(originArray) // [1,[1,2,3],{a:1}]; 修改cloneArray的第一个值不影响原数组 cloneArray[1].push(4); cloneArray[2].a = 2; console.log(originArray); // [1,[1,2,3,4],{a:2}] //修改cloneArray的对象和数组则会影响原数组，说明引用的是同一个对象和数组 3、Object.assign()Object.assign是ES6新添加的接口，主要的用途是用来合并多个JavaScript的对象。 Object.assign()接口可以接收多个参数，第一个参数是目标对象，后面的都是源对象，assign方法将多个原对象的属性和方法都合并到了目标对象上面，如果在这个过程中出现同名的属性（方法），后合并的属性（方法）会覆盖之前的同名属性（方法）。 -------------------简单情况都是基本类型时------------------ let srcObj = {'name': 'lilei', 'age': '20'}; let copyObj2 = Object.assign({}, srcObj); console.log('srcObj', srcObj); //'name': 'lilei', 'age': '20' console.log('copyObj2', copyObj2); //'name': 'lilei', 'age': '20' srcObj.name=\"zhangsan\"; console.log('srcObj', srcObj); //'name': 'zhangsan', 'age': '20' console.log('copyObj2', copyObj2); //'name': 'lilei', 'age': '20' copyObj2.age=\"10\"; console.log('srcObj', srcObj); //'name': 'zhangsan', 'age': '20' console.log('copyObj2', copyObj2); //'name': 'lilei', 'age': '10' ---------------------------有引用类型时---------------------------- let srcObj = {'name': 'lilei', 'grade': {'chi':\"80\", 'eng':\"100\"}}; let copyObj2 = Object.assign({}, srcObj); copyObj2.name=\"zhangsan\"; copyObj2.grade.chi=\"50\"; console.log('srcObj', srcObj); //name: \"lisi\" grade: {chi: \"50\", eng: \"100\"} console.log('copyObj2', copyObj2); //name: \"zhangsan\" grade: {chi: \"50\", eng: \"100\"} 4、扩展运算符const originArray = [1,2,3,4,5,[6,7,8]]; const originObj = {a:1,b:{bb:1}}; const cloneArray = [...originArray]; cloneArray[0] = 0; cloneArray[5].push(9); console.log(originArray); // [1,2,3,4,5,[6,7,8,9]] const cloneObj = {...originObj}; cloneObj.a = 2; cloneObj.b.bb = 2; console.log(originObj); // {a:1,b:{bb:2}}","categories":[{"name":"-JavaScript","slug":"JavaScript","permalink":"https://nwebstone.github.io/categories/JavaScript/"}],"tags":[]},{"title":"TS_02","slug":"TS-02","date":"2022-04-18T08:24:11.000Z","updated":"2022-04-18T10:30:42.556Z","comments":true,"path":"posts/5.html","link":"","permalink":"https://nwebstone.github.io/posts/5.html","excerpt":"","text":"TS_02类JavaScript 语言中，生成实例对象的传统方法是通过构造函数 ES6之后开始使用class创建类 类就是具有相同特征的一类事物,比如猫.狗..都是动物类,具有动物类的基本属性和行为 可以将具有共同特征的事物抽象为一个类,类中定义公共属性和公共方法, function Cat(name,color){ //构造函数 this.name = name; this.color = color; this.type='动物'; this.eat = function(){console.log(\"吃老鼠\")}; }; 原型中 Cat.prototype.type='动物'; Cat.prototype.eat = function () { return console.log(\"吃老鼠\"); }; var cat1 = new Cat(\"大明\",\"黄色\"); var cat2 = new Cat(\"小明\",\"白色\"); 使用class声明一个类 在ts中声明一个类的时候,不要忘记指定类中属性类型,在定义函数的时候注意参数的类型 class Phone { brand:string price:number color:string constructor(brand:string,price:number,color:string){ this.brand = brand this.price = price this.color = color } static sendMessage(message:string,name:string){ console.log(`给${name}发送了一条消息,内容是${message}`); } } Phone.sendMessage('你好!!','jack') 修饰符ts中引入的修饰符,可以对变量的访问权限进行限制 常用的修饰符有以下几个public,static,protected,private,abstract public修饰符public修饰的属性在类的外部,子类,类的内部都可以访问到 class Person { //创建一个person类 public name:string constructor(name:string){ this.name = name } public run(){ console.log(`${this.name}在跑步`); } } class youth extends Person{ constructor(name:string){ super(name) } } let xiaohong = new youth('xiaohong') xiaohong.run() //在父类外可以访问到父类属性与方法 protected在类的外部访问不到属性,在类和子类的内部可以进行访问 export class Person { protected name:string constructor(name:string){ this.name = name } public run(){ console.log(`${this.name}在跑步`); } } class youth extends Person{ constructor(name:string){ super(name) } playGame(){ console.log(this.name,'玩游戏'); } } let xiaohong = new youth('xiaohong') xiaohong.run() //在父类外可以访问到父类属性与方法 // console.log(xiaohong.name); // 在类的外部是访问不到name属性的 xiaohong.playGame() // 子类中可以访问方法和变量 private只能在当前的类中进行使用,不能再子类和父类中进行使用 export class Person { private name:string constructor(name:string){ this.name = name } private run(){ console.log(`${this.name}在跑步`); } } class youth extends Person{ constructor(name:string){ super(name) } playGame(){ console.log(this.name,'玩游戏'); } } let xiaohong = new youth('xiaohong') // xiaohong.run() //在父类外不可以访问到父类属性与方法 // console.log(xiaohong.name); // 在类的外部是访问不到name属性的 // xiaohong.playGame() // 子类中不可以访问方法和变量 抽象类与抽象方法抽象类: abstract 修饰， 里面可以定义普通方法和抽象方法,也可以不定义抽象方法。 只要有抽象方法(abstract method)的类必须声明为抽象类(abstract class) 抽象方法的声明 abstract protected run(name:string):void 抽象方法不用在类中进行实现,继承抽象类的子类必须实现抽象类的方法 多态:父类定义一个方法不去实现，让继承它的子类去实现 每一个子类有不同的表现 注意：使用多态基础是类的继承或者接口实现 /** * Animal 是一个抽象类，里面含有一个eat()抽象方法 */ abstract class Animal{ public name:string; constructor(name:string){ this.name=name; } //抽象方法 ，不包含具体实现，要求子类中必须实现此方法 abstract eat():any; //非抽象方法，无需要求子类实现、重写 run(){ console.log('非抽象方法，不要子类实现、重写'); } } class Dog extends Animal{ //子类中必须实现父类抽象方法，否则ts编译报错 eat(){ return this.name+\"吃肉\"; } } class Cat extends Animal{ //子类中必须实现父类抽象方法，否则ts编译报错 eat(){ return this.name+\"吃鱼\"; } } var dog =new Dog(\"tom\"); var cat=new Cat(\"kitty\"); console.log(dog.eat()); console.log(cat.eat()); //多态 ，一种事物的不同表现形态。如下面的代码中 先声明变量f是Animal类型，具体是Dog还是Cat，在new 对象时才知道 //如果是Dog，则f.eat()调用的是Dog类中的eat方法；如果是Cat，则f.eat()调用的是Cat类中的eat方法，这就是多态！！！ var f:Animal;//声明变量为Animal类型 //f=new Dog(\"sunny\"); f=new Cat(\"sunny\"); console.log(f.eat()); 接口这里的接口是一种变量,该变量中规定了一定的属性 对象实现接口使用接口对对象中的变量进行规范约束 interface obj { name:string, age:number height?:number readonly weight:number } //对象实现接口必须实现接口中的所有属性,不多不少 let xiaoming:interface = { name:\"xaioming\", age:19, height:189, weight:180 } 类实现接口类实现接口需要使用关键字implements 类实现接口之后,必须实现接口中的所有属性和方法,但是类中还可以有其他的方法(只多不少) interface obj { name:string age:number } class Person implements obj { name:string // 这是定义属性及类型 age:number// height:number constructor(name:string){ this.name=name } action(){ console.log(\"正在跑步!\") } } 接口的功能(理解)如果有一防盗门和一辆汽车都有报警和灯的功能 就可以将共同过的报警功能抽离出来,定义为一个接口,让防盗门和汽车都实现这个接口 接口中只是定义了相关属性和方法名及参数类型,不涉及实现功能,只提供一种规范 interface Light{ //定义了一个灯的接口,其中有开关灯的方法 lightOff():void; lightOn():void } interface Alarmer {//定义了一个报警的接口 alarm():void // 接口规定有一个alarm()方法 } class Door{ //定义了一个通用的门类 constructor(){ } } class SecureDoor extends Door implements Alarmer,Light{ alarm(): void {//定义防盗门类,实现接口,实现接口中的方法 } lightOff(): void { } lightOn(): void { } } class Car implements Alarmer,Light { alarm(): void {//实现接口方法 } lightOff(): void { } lightOn(): void { } } 接口与类的区别​ 类可以创建对象，接口不可以 ​ 类只可以继承、接口是实现 一个类可以实现多个接口一个类只能继承一个类 一个接口既可以继承类又可以继承接口 接口继承接口​ 一个接口继承了另外一个接口，就继承了其中属性 A extends B ==&gt;接口A继承了接口B,就继承了其中的属性与方法 C implements A ===》 C中要实现A和B两个接口中的属性 //接口继承接口 interface Animal{ eat():void; } interface Person extends Animal{ work():void; } class Web implements Person{ name: string constructor(name:string){ this.name = name } [propName: string]: any; age: number; sex: string; eat () { console.log(`${this.name}喜欢吃馒头`) } work(){ console.log(`${this.name}写代码`) } } var w = new Web('ruby') w.eat() w.work() 接口继承类当接口继承了一个类类型时，它会继承类的成员但不包括其实现。 就好像接口声明了所有类中存在的成员，但并没有提供具体实现一样。 接口同样会继承到类的private和protected成员。 这意味着当你创建了一个接口继承了一个拥有私有或受保护的成员的类时，这个接口类型只能被这个类或其子类所实现（implement）。 当你有一个庞大的继承结构时这很有用，但要指出的是你的代码只在子类拥有特定属性时起作用。 这个子类除了继承至基类外与基类没有任何关系。 class Control { // 定义一个类 private state: any; // 定义一个私有属性 } interface SelectableControl extends Control { // 接口继承了类 select(): void; } class Button extends Control implements SelectableControl { // 类继承了类由实现了接口 select() {} } class TextBox extends Control { // 类继承了类 } class Image implements SelectableControl { //类实现接口 select() {} } 出现以下的异常 ⨯ Unable to compile TypeScript: src/interface_8.ts(54,7): error TS2300: Duplicate identifier 'Image'. src/interface_8.ts(54,7): error TS2420: Class 'Image' incorrectly implements interface 'SelectableControl'. Property 'state' is missing in type 'Image'. 在上面的例子里，SelectableControl包含了Control的所有成员，包括私有成员state。 泛型泛型就是使用一个泛型变量来表示任意的变量类型,在定义函数或者是指定数据类型的时候可以使用泛型. 函数声明时使用泛型使用泛型定义函数,在函数调用的时候统一指定函数类型 泛型的使用有助于避免相同功能但是类型不同的函数 泛型函数,通常用来指定函数的参数类型\\返回值类型 function foo&lt;T&gt;(x:T,y:T):T[]{ return [x,y] } // 函数声明 function f1&lt;T&gt;(x:T):T{ return x } f1&lt;number&gt;(1) // 函数表达式 let f2 = function&lt;N&gt;(x:N):N{ return x } var funcTest = &lt;T&gt;(x:T):T=&gt; x 泛型约束如何使用泛型指定几个类型的变量都有共同的属性 可以使用一个接口来约束变量类型具有什么样的属性,在使用泛型的时候让泛型变量受到接口的约束 //错误示例 //返回值是一个参数的长度,但是泛型函数的参数可以指定任意的类型,如果指定的类型是unmber,那么就是没有length属性的,如何指定泛型变量使用的是具有length属性的变量类型 function func5&lt;T&gt; (arg: T): void { console.log(arg.length); // 错误: T不存在length属性 比如数值等 } //解决方法 //定义一个接口,接口中定义了length属性 interface Length{ length:number } //在使用泛型的时候让泛型变量受到接口的约束 function func5&lt;T extends Length&gt; (arg: T): void { console.log(arg.length); } 接口泛型之前学过可以使用接口来规范函数的输入和输出 interface SearchFun{ //定义一个接口,规范函数的输入和输出 (a:string,b:string):boolean } //函数实现接口 let func6:SearchFun = function(str1:string,str:string):boolean{ let i = str1.search(str2) return i === -1 } func6('abc','a') 有些函数变量类型不同但是函数功能相同,可以使用泛型的形式进行书写 因为接口可以约束函数的类型,所以可以直接在接口中使用泛型 function func&lt;T&gt;(a:T,b:T):T[]{ return [a,b] } //方式2泛型接口,泛型类型写在接口名之后 interface SearchFun&lt;T&gt;{ (a:T,b:T):T[] } //实现接口的时候指定泛型变量 let func:SearchFun&lt;string&gt; = function&lt;T&gt;(a:T,b:T):T[]{ return[a,b] } func('abc','a') //函数声明的时候不用加泛型 //泛型接口,泛型变量写在函数之前 interface SearchFun2{ &lt;T&gt;(a:T,b:T):boolean } let func7:SearchFun2 = function&lt;T&gt;(a:T,b:T):boolean{ return a === b } //使用函数的时候书写泛型 func7&lt;string&gt;('abc','a') 数组泛型//定义一个普通函数,规定号函数的种类 function createArray(num:number,str:string):string[]{ let a:string[] = [] for(let i = 0;i&lt;num;i++){ a[i] = str } return a } createArray(4,'abs') //使用泛型定义,可以在使用的时候指定数组变量的类型 function createArray(num:number,str:string):string[]{ let a:string[] = [] for(let i = 0;i&lt;num;i++){ a[i] = str } return a } createArray(4,'abs') 枚举类型enum类型是对JavaScript标准数据类型的一个补充对于数组中获取数据，只能通过数组来获取，不能通过名称来获取 默认情况下，从0开始为元素编号。 你也可以手动的指定成员的数值。 如果第一变量指定为1,后面的依次增加1 enum Color { Red, Green, Blue } var co1:Color = Color.Red console.log(co1); // 0 可以通过值拿到索引,默认从零开始进行编号 enum Color { Red=1, // 可以手动指定成员的数值 Green, Blue } var co1:Color = Color.Red console.log(co1); // 1 可以通过值拿到索引,默认从零开始进行编号 var co2 = Color[2] //通过索引可以拿到对应的value var co3 = Color[1] var co4 = Color[0] var co5 = Color[3] console.log(co2); // Green,Red的起始值为1,后面依次增加 console.log(co3) console.log(co4); console.log(co5); 元组数组合并了相同类型的对象，而元组（Tuple）合并了不同类型的对象。 我们知道数组中元素的数据类型都一般是相同的（any[] 类型的数组可以不同），如果存储的元素数据类型不同，则需要使用元组 let x: [number,string]; x = [5,'abc'] var ff =function(){ let x1: [string, number]; x1 = ['abc', 5]; x1[1] = 10; console.log(x1); // [\"abc\", 10] } ff()","categories":[{"name":"-TypeScript","slug":"TypeScript","permalink":"https://nwebstone.github.io/categories/TypeScript/"}],"tags":[]},{"title":"TS_01","slug":"TS-01","date":"2022-04-17T15:45:19.000Z","updated":"2022-04-17T16:39:47.058Z","comments":true,"path":"posts/4.html","link":"","permalink":"https://nwebstone.github.io/posts/4.html","excerpt":"","text":"TypeScriptTS的数据类型TS在定义变量的时候必须指定变量的数据类型 常用的数据类型 ES6: //基本数据类型 String Number Boolean null Symbol //引用数据类型 Array Object Function TS: void any never 元组 枚举 高级类型 基本使用形式使用变量:类型的形式声明一个变量 //定义变量要指定参数的类型 let num: number = 14; console.log(num); //函数在定义的时候,要指定参数的类型 function sum(num1:number,num2:number){ return num1+num2 } // 基本数据类型的定义 let flag:boolean = false; //布尔类型 let num:number = 15; //数值类型 let str:string = 'abc'; //字符串类型 let str2:string=`hello,${str}`; let msg:string = `hello,${str},${num}`; let u: undefined = undefined; let n: null = null; 联合类型联合类型,一个变量可以设置多个数据类型 变量:类型1 | 类型2 =值 let a:number|string 任意类型任意类型: 变量:any = 值 let a : any 引用数据类型数组的定义方式简单定义方式// 数组,简单方式, 变量名:类型+[] let arr:number[] = [1,2,3,4,6] let arr1:string[] = [\"a\",\"b\"] let arr2:any[] = [] 数组泛型 数组泛型 T为泛型变量 不指定变量的类型,而是在使用的时候进行定义类型 Array let arr3:Array&lt;number&gt; = [2,3,4,5] let arr4:Array&lt;string|number&gt; = [2,3,4,5,\"a\"] 使用接口定义数组//定义接口,对对象属性约束 interface&nbsp;Person{ &nbsp;&nbsp;name:&nbsp;string; &nbsp;&nbsp;age:&nbsp;number; } //定义数组接口 interface&nbsp;NumberArray&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[index:number]:&nbsp;Person;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } let&nbsp;arrType3:&nbsp;NumberArray&nbsp;=&nbsp;[{name:'张三'，age:&nbsp;20}] let&nbsp;arrType4：Array&lt;Person&gt;&nbsp;=&nbsp;[{name:'张三'，age:&nbsp;20}] let&nbsp;arrType5：Person[]&nbsp;=&nbsp;[{name:'张三'，age:&nbsp;20}] NumberArray 表示：只要 index 的类型是 number，那么值的结构类型必须是符合Person接口。 对象数据类型的定义对象及接口的定义接口:可以用于对对象的形状进行描述 接口:就是标准,比如不同的手机,要是有相同的接口就好了 ​ 对象实现接口,就要实现接口的标准,就相当于对对象进行了一个约束 ​ *定义方式,与类类似 // 接口中规范了其中变量的类型 interface Person{ //定义接口 readonly name:string; // 只读属性 age?:number; // 可选属性 sex:string; // 必填属性 [propName:string]:any //任意属性 } /* 对象实现了一个接口 对象:必须实现所有的接口属性, */ let obj:Person ={ name:'zs', age:18, sex:'male' } ​ 接口就是用代码描述一个对象必须有什么属性（包括方法），但是有没有其他属性就不管了。 ​ 1.声明变量使用接口的时候，变量参数必须和接口中的参数一致，不能多也不能少； ​ 2.readonly可以在接口中声明只读变量 ​ 3.使用?可以声明一个变量在对象中是可选择的 比如name?: string ​ 4.[propName:类型]:any 任意属性 propName是一个变量 ​ 一旦定义了任意属性,必填属性和可选属性必须是任意属性的自属性 ​ 只要propName的类型是string,他对应的值应该是any类型的 函数的定义函数定义 函数声明,输入和输出的类型都要定义,有返回值必须规定类型,没有返回值使用void //函数声明 function(n1:number,n2:number) :number{ return n1+n2 } // 函数表达式 let f3 = function(n1:number,n2:number):number{ return n1+n2 } // 函数的默认值 let f4 = function(n1:number=1,n2:number=2):number{ return n1+n2 } // 可选参数,参数之后加?表示可选参数,可选参数必须在最后面 let f5 = function(n1:number=1,n2?:number=2):number{ return n1+n2 } 接口在函数中的使用参数是对象的时候,要对对象中的每个类型进行约束,写在形参的位置非常麻烦,使用接口简化 function f6(obj:{id:number,name:string}):number{ //形参十分复杂,使用接口转化 return obj.id } let o = {id:2,name:\"zs\"} f6(o) //先定义接口,让参数对象实现接口即可 interface objName{ id:number; name:string } function f7(obj:objName):number{ return obj.id } 接口声明函数nterface&nbsp;SeachFunc{ //函数接受两个参数 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;（source:string,subString:string）:boolean }&nbsp;&nbsp;&nbsp;&nbsp; let&nbsp;mySearch:SearchFunc; mySearch&nbsp;=&nbsp;function(source:&nbsp;string,subString:string){ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;source.search(subString)&nbsp;!==&nbsp;-1&nbsp;&nbsp; } 联合属性在参数中使用联合属性在参数中使用,变量必须有两种类型共同的属性 //这种定义方式是错误的,返回的是str的length属性,但是定义时有string和number两种属性 //str是number时是没有length的,报错 function f8(str:string|number):number{ return str.length } //string和array都有长度 function f8(str:string|Array&lt;string&gt;):number{ return str.length } 泛型在函数定义中的使用泛型,在定义函数或者是接口的时候不定义具体的变量类型,使用的时候在指定类型 // 泛型,在定义函数或者是接口的时候不定义具体的变量类型,使用的时候在指定类型 function f9(x:string,y:string):string[]{ return [x,y] } function f10(x:number,y:number):number[]{ return [x,y] } //前面两个函数只是变量类型不同,函数工能相同,使用泛型进行定义,简化代码 function f11&lt;T&gt;(x:T,y:T):T[] { return [x,y] } 剩余参数在函数中的使用//ES6...items在形参中使用,用在最后,拿到的是一个数组 function&nbsp;push(array,...items){ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;items.forEach(function(item){ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;array.push(item) })&nbsp;&nbsp; } let&nbsp;a&nbsp;=&nbsp;[]; push(a,1,2,3) // 传入第一个参数是一个数组,第二个参数也是一个数组,可以用数组类型 function&nbsp;push(array:any[],...items:any[]){ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;items.forEach(function(item){ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;array.push(item); &nbsp;&nbsp;&nbsp;&nbsp;})&nbsp;&nbsp; } let&nbsp;a&nbsp;=&nbsp;[] push(a,1,2,3) undefined和nulllet&nbsp;udf:&nbsp;undefined&nbsp;=&nbsp;undefined let&nbsp;nu:&nbsp;null&nbsp;=&nbsp;null 在TS中,undefined和null是任何类型的子类型,所以可以被赋值给其他类型 let&nbsp;num3:&nbsp;number&nbsp;|&nbsp;undefined&nbsp;|&nbsp;null&nbsp;=&nbsp;111 nevernever:永远不会有返回值的类型 1,函数抛出异常,永远不会有返回值,类型为never //&nbsp;函数抛出异常,永远不会有返回值,类型为neverlet&nbsp;error&nbsp;=&nbsp;()&nbsp;=&gt;&nbsp;{throw&nbsp;new&nbsp;Error('error') } 2,死循环函数永远没有返回值,类型为never //&nbsp;死循环函数永远没有返回值,类型为 neverlet&nbsp;endless&nbsp;=&nbsp;()&nbsp;=&gt;&nbsp;{while(true)&nbsp;{} } voidjs中void操作符可以使任何一个表达式返回undefined void&nbsp;0&nbsp; //&nbsp;将返回undefined 在TS中,void类型表示没有返回值,没有返回值的函数,他的类型就是void类型","categories":[{"name":"-TypeScript","slug":"TypeScript","permalink":"https://nwebstone.github.io/categories/TypeScript/"}],"tags":[]},{"title":"浏览器工作原理和V8引擎","slug":"浏览器工作原理和V8引擎","date":"2022-04-17T05:45:09.000Z","updated":"2022-04-17T23:40:37.706Z","comments":true,"path":"posts/3.html","link":"","permalink":"https://nwebstone.github.io/posts/3.html","excerpt":"","text":"浏览器工作原理和V8引擎前端开发最主要的就是html 、css、JavaScript Javascript是非常重要的 JavaScript是Vue、React、Angular、uniapp、taro、ReactNative的基础 Javascript应用Web开发：React、Vue 、Angular 移动端开发:Reactive、Weex 小程序开发：微信小程序、支付宝小程序、uniapp、taro 桌面应用开发：Electron 后端开发：Node环境，比如express、koa、egg.js TypeScript会不会替代JavaScript??JavaScript是不会对变量进行检测，所以有很多方案，flow，TypeScript给js带来了类型检测的思想。 JavaScript是不会被替代的。 语言分发展JS是一门高级的编程语言 机器语言===》汇编语言===》高级语言（C 、C++、Java、JavaScript、Python 高级语言计算机是不认识的，需要将高级语言转变为机器指令 计算机语言运行的过程:高级语言===》汇编语言===》机器语言 高级语言又可以分为解释型语言和编译型语言 C、C++是先将代码编译为可执行文件，是一种编译型语言 JS、Python是解释型语言 JS是如何在浏览器中执行node和浏览器中都已js的解析引擎 浏览器下载资源的过程在浏览器中输入 域名==》DNS解析为ip地址（服务器的地址）==》服务器会返回一个index.html网页 ==》浏览器会对html页面进行解析==&gt;在解析html的过程中会遇到html、css、script，下载相应的资源 ===》执行相应的资源的解析 浏览器的内核不同浏览器会又不同的内核 GecKo:早期被NetScope和Mozilla、Firefox使用 Trident:微软开发，被IE4-IE11浏览器使用，但是Edge浏览器已经转向Blink Webkit:苹果基于KHTML开发、开源，用与Safari，Chrome之前也进行使用 Blink:是WebKit的一个分支，Google开发，目前应用于Google Chrome、Edge、Opera浏览器 常说的浏览器内核指的是浏览器的排版引擎 排版引擎（layout engine)，也称为浏览器引擎（browser engine)、页面渲染引擎（rendering engine) 浏览器的渲染过程loader Loader模块负责处理所有的HTTP请求以及网络资源的缓存，相当于是从URL输入到Page Resource输出的变换过程。HTML页面中通常有外链的JS/CSS/Image资源，为了不阻塞后续解析过程，一般会有两个IO管道同时存在，一个负责主页面下载，一个负责各种外链资源的下载。 注意：虽然大部分情况下不同资源可以并发下载异步解析（如图片资源可以在主页面解析显示完成后再被显示），但JS脚本可能会要求改变页面，因此有时保持执行顺序和下载管道后续处理的阻塞是不可避免的 渲染过程1、浏览器首先下载下来的是html,浏览器内核中的html parser将html转变为DOM树。 ​ 注意：DOM形成之后，JavaScript可以对DOM进行操作 ​ 同时css样式也会被css parser进行解析成为css rules ​ DOM tree + css rules 形成render tree 2、layout计算（根据浏览器的大小和状态），计算出最终的render tree 3、painting 4、display jS代码可能对dom进行操作，可能发起请求，所以在生成dom之后会执行js JS引擎高级语言==》浏览器和node==》最终仍然是被计算机所执行 但是CPU只认识自己的指令集，实际上是机器语言，才能被CPU执行 JS引擎：将JS转换为机器语言 常见的JS引擎：SpiderMonkey:收款JS引擎 Chakra:微软开发，用于IT浏览器 JSCore：WebKit中的JS浏览器 V8引擎：Google开发的 JS引擎与浏览器内核的关系V8引擎是使用C++编写的，开源的高性能的JS和WebAssembly引擎，用于Chrome和Node.js等 实现ECMAScript和WebAssembly，并在Windows7或者更高版本使用，mac OS10.12+ JS引擎解析过程描述JS===&gt;V8引擎Parser解析(词法分析和语法分析===》解析成ast树（抽象语法树） ​ ===》ignition转变为字节码==》执行 词法分析：将关键字，标识符，变量进行解析称号对象形式 const name = 'zs' 将词解析为tokens:[{type:\"keyword\",value:\"const\"},{type:\"identifier\",value:\"name\"}.....] ast树可以被ignition被转换为字节码 JS代码为什么不能直接转变为机器指令而是转变为字节码？？字节码是跨平台的，在任何一个平台再将字节码转变为汇编指令，再转变为机器指令，运行 一个函数，如果多次执行，每次指向都要进行由字节码到汇编指令，再转变为机器指令的过程，很浪费性能，如何进行解决？？ V8引擎中TurboFan会收集信息，将多次执行的代码标记为hot，将这些代码转变的机器指令存储起来，下次执行时可以方便调用。 如果一个函数或者时方法前后两次传递的参数类型不一致，V8引擎中有Deoptimization，将之前保存的函数机器指令再次转变为字节码，重新转换机器指令，进行执行，相当V8引擎进行代码优化。 如果编写的时TypeScript代码，指向效率会比原生的JS语法高，因为规定了相应的数据类型 抽象语法树的应用babel：ts==》ast树==》generate code ==&gt;js代码 vue中的中渲染结构==》最终都是执行的render函数==》template==&gt;要将html字符串转变为结构， ​ 字符串==》ast树==》VS Node==》html结构 JS的预解析过程Bink将源码交给V8引擎，Stream获取到源码并且进行编码转换 Scanner会对源码进行词法解析，词法分析会将代码解析成为tokens 接下来tokens会被转化称为sat树,经过PreParser和Parser: ​ 1.Parser就是直接将tokens转变为ast树 ​ 2.PreParser称之为预解析,为什么需要进行预解析 ​ 这是因为并不是所有的JS代码，在一开始的时候就会被执行，如果对所有的js代码都解析会影响网页的运行效率。 ​ V8引擎实现类Lazy Parsing(延迟解析)，作用是将暂时不必要的函数进行预解析，也就是说只解析暂时需要的内容，而对函数的全量解析在函数被调用的时候才会进行。 function outer(){ function inner(){ console.log('inner') } } outer() outer内部定义了inner函数，但是inner函数没有被调用，所以只会对其进行预解析 总结JS的重要性 浏览器的工作原理 使用到V8引擎中的loader,parser,Ignition，turboFan等模块 代码分析全局变量的解析过程var name = 'zs' var num1 = 20 var num2 = 30 var result = num1+num2 解析过程 1、代码解析 ​ a.在进行解析之前V8引擎在堆内存中会创建一个**globalObject对象（全局对象Go)**，会有String,Date,Number…全局内容） ​ b.在这个对象中有一个window属性，这个属性指向globalObject(自己的属性指向自己) ​ c.解析代码时候，会将全局的属性挂载到全局对象当中，但是这个属性是没有值的,全部都是undefined //以一段伪代码表示 // 伪代码,此时函数还没有执行 var globalObject= { String:\"类\", Date:\"类\", setTimeout:\"函数\", name:undefined, num1:undefined, result:undefined } 此时,在函数定义之打印变量的值,会得到undefined,但不会报错 2、运行代码 ​ a.为了执行代码，V8引擎会创建执行上下文栈（函数调用栈）（Executions Context Stack ECSSstack） ​ 代码运行会先从磁盘加载到内存中，会对内存进行划分，一个是栈结构，一个是堆结构。 ​ 代码想要执行的时候需要放到执行上下文栈中进行执行，执行完之后弹出栈。 ​ b.一般执行上下文栈式放的是函数的，为了全局代码能够执行，会创建全局执行上下文（Global Execution Context Stack GEC) ​ 这里的代码不是函数,为了执行这些代码,会创建全局执行上下文 ​ 全局执行上下文就可以放入到执行上下文栈中进行执行 ​ 全局执行上下文中维护的是VO(variable Object 变量对象),VO指向的是GO ​ *依次执行代码** 函数的解析 1.解析过程 ​ a.V8创建全局对象,将name添加到GO中 ​ b.编译解析过程是不会执行函数的,所以就跳过foo(),继续向后编译 ​ c.遇到函数定义之后,将foo属性中添加到GO中,V8此时会开辟一块内存空间(有一个内存地址,比如0xa00),存储函数 ​ 这个空间主要包括两部分,一个是父级作用域,就是函数的上一层作用域,另一部分保存函数的函数体 ​ GO中foo属性对应的是函数的地址 2.执行过程 ​ a.var name= ‘zs’,通过VO找到GO,更改值 ​ b.指向到foo(),通过VO找到GO中的foo==&gt;对应的函数地址====&gt;此时创建函数执行上下文(Functiona Execution Context FEC) ​ 函数执行上下文中也有一个VO,这个VO指向的是AO(Activation Object) ​ 在函数执行之前会创建AO,AO存放的是函数内部定义的变量,作用类似于GO,AO中的变量开始也是undefined,函数执行完毕后,函数的 ​ 执行上下文弹出,会被销毁掉,如果再次执行上下文会再次创建函数执行上下文 //函数解析示例 var name=\"zs\" foo() function foo() { console.log(\"foo\"); }","categories":[{"name":"-JavaScript","slug":"JavaScript","permalink":"https://nwebstone.github.io/categories/JavaScript/"}],"tags":[{"name":"-JS进阶","slug":"JS进阶","permalink":"https://nwebstone.github.io/tags/JS%E8%BF%9B%E9%98%B6/"}]},{"title":"HTML_01","slug":"HTML_01","date":"2022-04-17T01:24:00.000Z","updated":"2022-04-17T03:14:44.455Z","comments":true,"path":"posts/2.html","link":"","permalink":"https://nwebstone.github.io/posts/2.html","excerpt":"","text":"HTML_01网页什么是网页？网站是指在因特网上根据一定的规则，使用 HTML 等制作的用于展示特定内容相关的网页集合。 网页是网站中的一“页”，通常是 HTML 格式的文件，它要通过浏览器来阅读。 网页是构成网站的基本元素，它通常由图片、链接、文字、声音、视频等元素组成。通常我们看到的网页，常见以 .htm 或 .html 后缀结尾的文件，因此将其俗称为 HTML 文件。 常用浏览器浏览器最主要的部分是浏览器内核，负责读取网页内容，整理讯息，计算网页的显示方式并显示页面。 浏览器 内核 备注 IE Trident IE、360极速浏览器、百度浏览器 Firefox Gecko 火狐浏览器内核 Safari Webkit 苹果浏览器内核 Chrome/Opera Bink Chrome/Opera浏览器内核，Bink其实是WebKit的分支 Web标准Web 标准是由 W3C 组织和其他标准化组织制定的一系列标准的集合。W3C（万维网联盟）是国际最著名的标准化组织。 为什么指定Web标准？不同的浏览器解析相同的html文件会有差异。 制定web标准的优点：使网站便于维护，网页内容能够被更加广泛的设备访问。 Web标准的构成一个页面主要有三部分组成：结构、样式和行为，分别对应前端必备技术，html，css，javascipt 标准 说明 结构（html） 搭建网页的基本结构，实现网页的布局 样式（css) 用于美化页面，网页元素的大小，颜色，样式 行为（javascript) 实现网页的动态效果和页面与用户的交互行为 HTML基本标签html页面中的基本标签结构 &lt;html&gt; &lt;head&gt; &lt;title&gt;标题&lt;/title&gt; &lt;/head&gt; &lt;body&gt; 主要内容 &lt;/body&gt; &lt;/html&gt; 在使用vscode时，使用！+tab可以自动给创建html文件的表头 &lt;!-- 文档类型的声名，告诉浏览器使用哪种HTML版本来显示网页，文档类型声名在最前面 --&gt; &lt;!DOCTYPE html&gt; &lt;!-- 定义当前文档显示的语言 en是英语 zh-CN是中文网页 --&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;!-- 定义使用哪种字符编码 --&gt; &lt;!-- 常用的字符编码格式：GB2312，BIG5,GBK，UTF-8(万国码)最常用 --&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;!-- 兼容性 --&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"&gt; &lt;!-- 视口 --&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;title&gt;标题&lt;/title&gt; &lt;/head&gt; &lt;body&gt; 主要内容 &lt;/body&gt; &lt;/html&gt; HTML常用标签标签具有语义化可以是页面的结构更加的清晰 h标签h是head的缩写，标题标签，共有六个等级，从h1到h6依次减小 &lt;h1&gt;标题内容&lt;/h1&gt; 主要：在h标签中文字会加粗变大，一个标签独占一行 p标签p是paragraph的缩写，段落标签，在标签内的为你单独为一个段落。 &lt;p&gt;这是一个段落标签&lt;/p&gt; 注意：段落中的文字会根究浏览器窗口的大小自动换行，段落与段落之间会有空隙。 br标签网页中的文本只有在到达浏览器右端的时候才能进行自动换行，如果希望某段文本进行强制换行可以使用br标签 &lt;br /&gt; 注意：br标签是一个单标签，br标签换行之后的文本上下是没有空袭的，段落标签换行后会形成两个段落，上下两个段落之间会有一定的空隙。 文本格式化标签文本格式化标签就是给文本添加一定样式的标签。 语义 标签 说明 加粗 或者是 strong标签语义更加强烈 倾斜 或者 经常全局曲消倾斜，用i标签放置小图标 删除线 或者 del标签语义更加强烈 下划线 或者 ins标签语义更加强烈 div与span标签div：是用来进行布局的，但是一行只能放一个 span：用于布局，一行可以有多个span标签 这里只简单了解一些两个标签不同，后面会详细说明。 图像标签&lt;!-- img标签用于定义页面中的图像 --&gt; &lt;img src=\"图片存放的路径\" alt=\"加载不出来时显示文本\" title=“鼠标经过之后会显示图片的标题” width=“100px” 设置宽度 height=\"100px\" 设置高度 border=“1px” 设置边框 /&gt; 相对路径与绝对路径相对路径：相对于当前文件的路径来说的，写路径的时候从当前路径开始写 ./表示当前路径 ../表示上一级路径 绝对路径：从磁盘的根路径开始找 比如c:/…… 绝对路径的缺点:如果将文件发给别人使用,会找不到资源 a标签超链接标签 &lt;!-- _blnk在新的页面打开链接 _self在当前页面打开链接 herf链接可以是外部链接如www.baidu.com 可以是空链接 herf=\"#\" 可以是内部的链接 herf=\"index.html\" --&gt; &lt;a herf=\"点击之后要跳转的链接\" target=\"_blank/_self\"&gt;文本\\图像\\表格&lt;/a&gt; 标签中的特殊字符","categories":[{"name":"-HTML","slug":"HTML","permalink":"https://nwebstone.github.io/categories/HTML/"}],"tags":[]},{"title":"02-博客诞生","slug":"02-博客诞生","date":"2022-04-16T19:10:51.000Z","updated":"2022-04-17T03:23:02.427Z","comments":true,"path":"posts/1.html","link":"","permalink":"https://nwebstone.github.io/posts/1.html","excerpt":"","text":"博客诞生","categories":[{"name":"-生活","slug":"生活","permalink":"https://nwebstone.github.io/categories/%E7%94%9F%E6%B4%BB/"}],"tags":[]},{"title":"博客与博主","slug":"01-博客诞生","date":"2021-05-27T13:00:00.000Z","updated":"2022-04-16T19:36:26.933Z","comments":true,"path":"posts/1.html","link":"","permalink":"https://nwebstone.github.io/posts/1.html","excerpt":"","text":"相遇皆是缘分 为什么建博客？肿么说了! 纯属个人兴趣，好玩，唉，就是玩!嘻嘻! 会有些成就感吧,拥有一个自己的博客写一些自己感兴趣的事或物,不是一件很酷的事嘛! 展望博客我会整理一些个人所学的知识（学前端的，也会捣鼓捣鼓一些其它的专业的知识）或生活方面有兴趣的事发到博客上供大家观摩 关于博主有位可爱的（小）朋友，给我取名叫 “仙气”，这是也是我博客上自居 “仙气” 的由来。喜欢自己所喜欢的，做自己想做的，追求自由与潇洒，多酷啊！ 想法是美好的，可现实… … 给大家推荐一首诗吧 《自由与爱情》---作者:裴多菲 ​ 生命诚可贵 ​ 爱情价更高 ​ 若为自由故 ​ 二者皆可抛 溜溜球啦！","categories":[],"tags":[]}],"categories":[{"name":"-JavaScript","slug":"JavaScript","permalink":"https://nwebstone.github.io/categories/JavaScript/"},{"name":"-TypeScript","slug":"TypeScript","permalink":"https://nwebstone.github.io/categories/TypeScript/"},{"name":"-HTML","slug":"HTML","permalink":"https://nwebstone.github.io/categories/HTML/"},{"name":"-生活","slug":"生活","permalink":"https://nwebstone.github.io/categories/%E7%94%9F%E6%B4%BB/"}],"tags":[{"name":"-JS进阶","slug":"JS进阶","permalink":"https://nwebstone.github.io/tags/JS%E8%BF%9B%E9%98%B6/"}]}